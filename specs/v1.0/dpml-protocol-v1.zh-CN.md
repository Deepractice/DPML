# DPML 协议规范 v1.0

**状态**: 草案  
**日期**: 2025年10月  
**作者**: 姜山 (Deepractice.ai)

---

## 摘要

本文档定义了 Deepractice 提示词标记语言（DPML）协议 1.0 版本。

DPML 是一种**三方 Prompt 协议**，通过结构化信息使计算机、AI 和人类能够在同一份文档上协同工作：

- **面向计算机的 Prompt**：属性驱动配置和执行
- **面向 AI 的 Prompt**：内容驱动理解和推理
- **面向人类的 Prompt**：结构实现观察和控制

传统 Prompt 只服务 AI。DPML 认识到现代 AI 系统需要三种不同类型的 Prompt——给机器的指令、给 AI 的上下文、给人类的可见性——并将它们统一到单一结构化文档中。

XML 独特的属性（机器语义）、内容（AI 语义）和 DOM 结构（人类可观测性）的组合，使其成为唯一能够同时服务这三方的格式。

---

## 目录

1. [引言](#1-引言)
2. [设计哲学：三方 Prompt 协议](#2-设计哲学三方-prompt-协议)
3. [术语](#3-术语)
4. [设计原则](#4-设计原则)
5. [协议概述](#5-协议概述)
6. [语法规范](#6-语法规范)
7. [元素规范](#7-元素规范)
8. [属性规范](#8-属性规范)
9. [内容规范](#9-内容规范)
10. [文件格式](#10-文件格式)
11. [验证规则](#11-验证规则)
12. [安全考虑](#12-安全考虑)
13. [IANA 考虑](#13-iana-考虑)
14. [参考文献](#14-参考文献)
15. [附录 A: 完整示例](#附录-a-完整示例)
16. [附录 B: ABNF 语法](#附录-b-abnf-语法)
17. [附录 C: 为什么选择 XML 而非 YAML/JSON](#附录-c-为什么选择-xml-而非-yamljson)

---

## 1. 引言

### 1.1 动机

现代 AI 系统涉及三个不同的利益相关方，每个都需要不同类型的信息：

- **计算机**需要结构化配置来初始化模型、注册 API 和管理执行
- **AI** 需要自然语言指令来理解角色、原则和行为
- **人类**需要可观测的结构来审计、调试和控制 AI 系统

传统方法将这三种信息强制放入不兼容的格式中：

- 纯文本 Prompt 服务 AI，但计算机无法解析，人类无法观察结构
- YAML/JSON 配置服务计算机，但给 AI 造成认知负担，人类看到的是扁平层级
- 分离的文件分散信息，需要同步并增加维护负担

**DPML 通过认识到这三种需求本质上都是"Prompt"**——引导系统行为的结构化信息——并将它们统一到单一文档中来解决这个问题。

### 1.2 目标

DPML 协议旨在：

1. **统一三方 Prompt**：使计算机、AI 和人类能够在同一份文档上协作
2. **利用结构化信息**：使用 XML 的多维语义（tag/attribute/content）来分离关注点
3. **实现可观测性**：支持 AI 系统的实时可视化和审计追踪
4. **保持简洁性**：在最大化表达能力的同时最小化认知负担

### 1.3 范围

本规范定义：

- **核心语法**：元素、属性和内容结构
- **元语义**：概念如何表达和组织
- **文件格式**：文档结构和约定
- **验证规则**：格式正确性和结构有效性

本规范不定义：

- **领域语义**：`<agent>`、`<task>` 等的具体含义（由领域规范定义）
- **运行时行为**：元素如何执行或解释
- **扩展机制**：详细的插件或命名空间系统（预留给未来版本）

### 1.4 需求语言

本文档中的关键词"必须（MUST）"、"禁止（MUST NOT）"、"要求（REQUIRED）"、"应当（SHALL）"、"不应（SHALL NOT）"、"应该（SHOULD）"、"不应该（SHOULD NOT）"、"推荐（RECOMMENDED）"、"可以（MAY）"和"可选（OPTIONAL）"按照 RFC 2119 中的描述进行解释。

---

## 2. 设计哲学：三方 Prompt 协议

### 2.1 重新理解"Prompt"

**传统定义**：Prompt 是给 AI 的文本，用于引导其行为。

**DPML 定义**：Prompt 是**引导系统行为的结构化信息**。

在任何 AI 应用中，实际上有三个需要 Prompt 的系统：

| 系统 | 需要知道 | 传统方法 | 问题 |
|------|---------|---------|------|
| **计算机** | 模型名称、API 密钥、超时值 | 配置文件（YAML/JSON） | AI 无法理解，人类看到扁平结构 |
| **AI** | 角色、原则、能力 | 文本 Prompt | 计算机无法解析，人类无法审计结构 |
| **人类** | 系统目的、当前状态、变更 | 文档 + 日志 | 与定义分离，难以维护 |

DPML 的核心洞察：**这些都是 Prompt，只是面向不同的受众。**

### 2.2 结构化信息是基础

信息的结构化程度决定了能够服务多少利益相关方：

```
非结构化（纯文本）
├─ ✓ AI 可以理解
├─ ✗ 计算机无法可靠解析
└─ ✗ 人类无法观察结构

半结构化（YAML/JSON）
├─ ✓ 计算机可以解析
├─ △ AI 需要处理键值路径
└─ ✗ 人类看到扁平层级

多维结构化（XML）
├─ ✓ 计算机：属性 = 配置
├─ ✓ AI：内容 = 自然语言
└─ ✓ 人类：DOM 树 = 可视结构
```

**关键原则**：信息结构不是开销——它是实现多方协作的机制。

### 2.3 DPML 如何实现三方 Prompt

单个 DPML 文档是三种 Prompt 的叠加：

```xml
<agent>
  <!-- 层 1：向计算机发出 Prompt（属性） -->
  <llm model="gpt-4" temperature="0.7" max-tokens="2000"/>

  <!-- 层 2：向 AI 发出 Prompt（内容） -->
  <prompt>
    你是一个专业的旅行规划助手。
    你擅长制定详细的行程，推荐当地特色体验。
  </prompt>

  <!-- 层 3：向人类发出 Prompt（结构 + 元数据） -->
  <metadata
    purpose="旅行规划助手"
    version="2.0"
    last-reviewed="2025-10-01"
    reviewer="张三"/>
</agent>
```

**处理流程**：

1. **计算机读取** `model="gpt-4"` → 初始化 GPT-4 客户端
2. **计算机读取** `temperature="0.7"` → 配置参数
3. **AI 读取** `你是一个专业的...` → 理解角色
4. **人类看到** DOM 结构 + 元数据 → 审计系统配置

**关键设计**：这三层共存且互不干扰。

### 2.4 为什么只有 XML 可行

#### 语义维度问题

不同格式具有不同的语义维度：

| 格式 | 语义维度 | 计算机 | AI | 人类 |
|------|---------|--------|-----|------|
| **YAML** | 2（键 + 值） | ✓ 可解析 | ✗ 缩进认知负担 | ✗ 扁平可视化 |
| **JSON** | 2（键 + 值） | ✓ 可解析 | △ 括号噪音 | ✗ 扁平可视化 |
| **XML** | 4（标签 + 属性 + 内容 + 结构） | ✓ 成熟解析 | ✓ 自然内容 | ✓ DOM 树 |

#### 为什么 YAML 失败

```yaml
# 所有信息被压缩到键值对中
agent:
  llm:
    model: gpt-4
    temperature: 0.7
  prompt: |
    你是助手
  metadata:
    version: "2.0"
```

问题：
- AI 必须理解层级路径（`agent.llm.model`）
- 缩进是语义的（AI 的认知负担）
- 所有信息在同一概念层级（机器配置 + AI 指令混合）
- 没有 AI 自然语言的"内容"空间

#### 为什么 XML 成功

```xml
<agent>
  <!-- 属性：机器的领域 -->
  <llm model="gpt-4" temperature="0.7"/>

  <!-- 内容：AI 的领域 -->
  <prompt>你是助手</prompt>

  <!-- 结构：人类的领域 -->
  <metadata version="2.0"/>
</agent>
```

优势：
- **标签**：概念定义（`<prompt>` 表示"这是一个 prompt"）
- **属性**：机器配置（解析器的键值对）
- **内容**：AI 的自然表达空间（无格式约束）
- **结构**：人类可见的层级（DOM 树）

**这是唯一具有足够语义维度来服务所有三方的格式。**

### 2.5 可观测的 AI 系统

人类需要的不仅仅是"读取配置"——他们需要**实时观察和控制**。

#### 静态定义（开发阶段）
```xml
<agent>
  <llm model="gpt-4"/>
  <prompt>你是助手</prompt>
</agent>
```

#### 动态状态（运行时）
```xml
<agent status="running" uptime="3600s">
  <llm model="gpt-4" tokens-used="1520" requests="23"/>
  <prompt version="2.0"/>
  <tools>
    <tool name="search" calls="15" avg-latency="120ms"/>
  </tools>
</agent>
```

#### 可视化渲染

同样的 XML 结构直接映射到 UI 组件：

```
┌─ Agent: 旅行助手 ──────────────┐
│ 状态: ⚫ 运行中 (1小时)         │
│ 模型:  GPT-4                   │
│ Token: 1,520 / 10,000          │
│                                 │
│ 📝 Prompt (v2.0)               │
│ 你是专业的旅行...              │
│                                 │
│ 🛠️ 工具                        │
│ • search      15次  120ms平均  │
└─────────────────────────────────┘
```

**关键优势**：DPML 的 DOM 结构使可视化成为自然转换，而非事后补充。

### 2.6 核心价值主张

**DPML 不是"用 XML 写 Prompt"。**

**DPML 是第一个认识到以下事实的协议：**

1. 现代 AI 系统需要**三种类型的 Prompt**（给计算机、AI 和人类）
2. 这些 Prompt 必须**统一**（不是分散在多个文件中）
3. 信息必须**结构性分离**（属性 ≠ 内容 ≠ 结构）
4. AI 系统必须**可观测**（运行时状态 + 静态定义）

**只有 XML 的多维语义能够满足所有四个要求。**

---

## 3. 术语

### 3.1 核心术语

**DPML 文档**：包含 DPML 标记的文件，通常使用 `.dpml` 或 `.pml` 扩展名。

**概念（Concept）**：由元素标签表示的语义单元。概念是共识术语（如 `role`、`agent`、`task`），承载人类和 AI 无需额外解释即可理解的含义。

**元素（Element）**：表示概念的 XML 标签结构。元素有开始标签、结束标签（或自闭合），可以包含属性和内容。

**属性（Attribute）**：附加到元素的键值对，主要服务于机器语义（解析、类型标记、标识）。

**内容（Content）**：元素内的文本或子元素，根据上下文服务于 AI 语义（自然语言）或机器语义（结构化数据）。

**保留属性（Reserved Attribute）**：在协议层面定义的、所有领域都可以使用的属性（当前为：`type`、`id`）。

**领域（Domain）**：DPML 的专门化区域，具有特定的元素定义（如 Agent 领域、Task 领域）。

**Prompt（提示）**：在 DPML 中，Prompt 是**引导系统行为的结构化信息**。DPML 文档同时包含三种类型的 Prompt：
- **机器 Prompt**：驱动计算机行为的属性和配置
- **AI Prompt**：驱动 AI 推理的内容和指令
- **人类 Prompt**：实现人类观察和控制的结构和元数据

### 3.2 设计原则术语

**约而不束**：建立结构和约定（约），但不限制 AI 的逻辑灵活性（不束）。

**认知负担（Cognitive Load）**：理解和处理信息所需的心智努力，DPML 通过简洁性和共识概念最小化这一负担。

**共识概念（Consensus Concept）**：具有广泛理解含义、无需额外解释的术语（如 `role`、`personality`、`agent`）。

**双重语义（Dual Semantics）**：每个语法元素同时服务于机器语义（解析、验证）和 AI 语义（理解、推理）。

---

## 4. 设计原则

### 4.1 约而不束原则

**核心哲学**：提供结构和方向，但不限制 AI 的创造性和适应能力。

**我们约束的内容**：
- 结构：XML 标签系统、层次结构、命名约定
- 语法：kebab-case 命名、保留属性
- 共识：使用既定概念，不发明术语

**我们不束缚的内容**：
- 逻辑：内容中没有 if-else 控制流
- 表达：内容中的自然语言自由
- 行为：原则优于规则，意图优于过程

**示例**：

```xml
<!-- [INVALID] 错误：束缚逻辑 -->
<rules>
  <if condition="user_angry">
    <response>我为给您带来的不便道歉</response>
  </if>
  <if condition="user_confused">
    <response>让我一步步解释</response>
  </if>
</rules>

<!-- [VALID] 正确：约束结构，不束缚逻辑 -->
<personality>
我是一个有同理心的助手。当用户不高兴时，我首先关注他们的情绪。
当用户困惑时，我会耐心解释。我始终保持专业和友好。
</personality>
```

### 4.2 最小化认知负担原则

**核心哲学**：AI 的注意力是稀缺资源。复杂规则会消耗认知带宽。

**证据**：实证测试显示：
- OpenAPI 规范（高认知负担）：30%+ 错误率
- Markdown 文档（低认知负担）：<10% 错误率
- DPML（最小认知负担）：<5% 错误率

**策略**：

1. **使用共识概念**：像 `role`、`agent`、`personality` 这样的术语具有内在含义
   ```xml
   <!-- 低熵：概念即定义 -->
   <role>
     <personality>...</personality>
   </role>

   <!-- 高熵：需要解释 -->
   <xuanwu>
     <qiankun>...</qiankun>
   </xuanwu>
   ```

2. **最小化核心概念**：将协议层面的概念保持在 5 个以下
   - 元素命名规则：1 个（kebab-case）
   - 保留属性：2 个（`type`、`id`）
   - 核心结构规则：2 个（基于 XML、单一根元素）

3. **分层复杂度**：结构（简单）+ 内容（灵活）

### 4.3 共识概念优先原则

**核心哲学**：在定义领域概念（元素名称）时，必须严格考证，选择共时性最大、最精准、语义性最强、最富有内涵的概念。

**四个选择标准**：

1. **共时性**
   - 在当前时代、当前领域有最广泛的共识
   - 跨文化、跨语言都能理解
   - 不使用过时或小众的术语

2. **精准性**
   - 概念边界清晰
   - 不会产生歧义
   - 一个概念对应一个明确的语义

3. **语义性**
   - 词汇本身承载丰富的语义
   - 不需要额外解释就能理解
   - AI 和人类都能直接理解

4. **内涵性**
   - 概念背后有深厚的理论基础
   - 承载着领域的最佳实践
   - 隐含了结构和关系

**信息论基础**：

共识概念是**压缩的知识**：

```
概念 "role" 的信息
├─ 显式信息：4个字母 "r-o-l-e"
└─ 隐式信息（免费）：
   ├─ 职责框架
   ├─ 能力边界
   ├─ 行为模式
   └─ 社会关系

总信息熵：极低（概念即定义）
```

自造词汇是**高熵**：

```
概念 "lero" 的信息
├─ 显式信息：4个字母 "l-e-r-o"
└─ 隐式信息：无
└─ 需要额外解释：
   ├─ "lero 是什么？"
   ├─ "lero 包含什么？"
   ├─ "lero 如何使用？"
   └─ 至少需要 50-100 个词解释

总信息熵：极高
```

**Token 经济学**：

使用共识概念节约 ~90% token 成本：

| 方案 | Token 成本 | AI 理解 | 信息传递 |
|------|-----------|---------|---------|
| 共识概念（`role`）| ~10 tokens | 即时、准确 | 完整、清晰 |
| 自造词汇（`lero`）| ~100+ tokens | 需要推理 | 需要解释 |

**决策框架**：

定义新的领域概念时：

```
Step 1: 识别概念需求
Step 2: 搜索共识概念
        ├─ 查询该领域的标准术语
        ├─ 参考权威文献、框架
        └─ 询问领域专家
Step 3: 评估候选概念
        ├─ 共时性：在当前时代是否广泛使用？
        ├─ 精准性：是否有明确边界？
        ├─ 语义性：是否自带含义？
        └─ 内涵性：是否承载深层知识？
Step 4: 计算信息熵成本
        └─ 需要多少词汇解释这个概念？
Step 5: 决策
        ├─ 所有标准 + → 采用
        ├─ 任一标准 - → 拒绝
        └─ 找不到合适概念 → 重新审视需求
```

**示例**：

[VALID] **好的选择**：
- `role`、`agent`、`personality`、`task`、`principle` - 都是各项标准  的共识概念

[INVALID] **糟糕的选择**：
- `lero` - 自造词，无共识（成本：50+ 词解释）
- `xuanwu` - 文化特定，非通用（成本：30+ 词）
- `thing` - 过于泛化，不精准（成本：20+ 词）

**验证方法**：

如果一个概念：
- 需要 >10 个词解释
- AI 需要额外上下文才能理解
- 跨文化、跨语言无法直接理解

→ 不是好的共识概念

**核心洞察**：

> **共识概念 = 免费的提示词**
>
> 选择概念 = 选择信息密度
>
> 好的概念 = 压缩的知识
>
> 自造概念 = 信息熵灾难

这个原则确保 DPML 作为标记语言的**经济性**和**高效性**，在词汇层面应用奥卡姆剃刀原理。

### 4.4 双重语义原则

每个语法元素服务于两个受众：

**机器语义**：
- 结构化、可解析、可验证
- 面向：编译器、验证器、工具
- 关注：正确性、效率

**AI 语义**：
- 概念化、上下文化、可推断
- 面向：大语言模型
- 关注：理解、推理

**元素平衡**：两种语义权重相等
**属性平衡**：偏重机器语义，轻量 AI 语义
**内容平衡**：由 `type` 决定

---

## 5. 协议概述

### 5.1 基础

DPML 是 **XML 1.0 的子集**，添加了特定的约定和约束：

- **基于**：XML 1.0 规范
- **增加**：命名约定、保留属性、元语义规则
- **移除**：DTD、XML Schema、处理指令、实体（为了简洁）

### 5.2 架构

```
┌─────────────────────────────────────────────┐
│           DPML 协议（元层）                 │
│  • 语法规则                                 │
│  • 元素/属性/内容 元语义                    │
│  • 保留属性                                 │
│  • 文件格式约定                             │
└─────────────────────────────────────────────┘
                    ▼
┌─────────────────────────────────────────────┐
│           领域规范                          │
│  • Agent 领域（对话式 AI）                  │
│  • Task 领域（状态机任务）                  │
│  • Role 领域（AI 人格）                     │
│  • Workflow 领域（工作流编排）              │
└─────────────────────────────────────────────┘
```

### 5.3 层次职责

**协议层**（本文档）：
- 如何定义概念（语法、结构）
- 元语义（元素/属性/内容的一般含义）
- 验证规则（格式正确性）

**领域层**（独立规范）：
- 存在哪些概念（如 `<agent>` 等特定元素）
- 领域语义（`<agent>` 的含义和要求）
- 领域特定验证

---

## 6. 语法规范

### 6.1 基本结构

DPML 文档必须是格式良好的 XML：

```xml
<concept-name attribute-name="attribute-value">
  内容或子元素
</concept-name>
```

### 6.2 命名约定

#### 6.2.1 元素名称

元素名称必须遵循 **kebab-case**：

- 全部小写字母
- 单词之间用连字符分隔
- 不使用下划线、不使用驼峰命名、不使用帕斯卡命名

**有效**：`<agent>`、`<travel-planner>`、`<api-config>`
**无效**：`<Agent>`、`<travelPlanner>`、`<api_config>`

**理由**：
- 与 HTML 传统一致
- 对人类和 AI 都可读
- 避免大小写敏感问题

#### 6.2.2 属性名称

属性名称必须遵循 **kebab-case**（与元素相同）：

**有效**：`api-key="..."`、`type="..."`、`model-name="..."`
**无效**：`apiKey="..."`、`API_KEY="..."`、`ModelName="..."`

### 6.3 字符编码

DPML 文档应该使用 UTF-8 编码。如果使用其他编码，应该包含 XML 声明：

```xml
<?xml version="1.0" encoding="UTF-8"?>
```

### 6.4 空白字符

- 内容中的空白字符会被保留（按照 XML 规范）
- 前导/尾随空白字符的处理由领域规范决定
- 属性值中的空白字符会被保留

---

## 7. 元素规范

### 7.1 元素即概念

在 DPML 中，元素表示**概念**而非仅仅是结构标记。

**概念的特征**：
- **完备性**：自包含的语义单元
- **共识性**：广泛理解的术语（非发明）
- **清晰性**：明确的边界和组成

**示例**：
```xml
<role>           <!-- 概念：角色定义 -->
  <personality>  <!-- 概念：人格特征 -->
    ...
  </personality>
</role>
```

### 7.2 元素结构

元素可以是：

1. **容器元素**：带有开始和结束标签
   ```xml
   <agent>
     <llm model="gpt-4"/>
     <prompt>你是一个助手</prompt>
   </agent>
   ```

2. **自闭合元素**：用于叶子概念
   ```xml
   <llm model="gpt-4" api-key="sk-xxx"/>
   ```

3. **文本内容元素**：仅包含文本内容
   ```xml
   <prompt>你是一个有用的助手</prompt>
   ```

### 7.3 协议层规则

协议定义：
- [VALID] **命名约定**：kebab-case
- [VALID] **概念原则**：使用共识术语

协议不定义：
- [INVALID] **特定元素**：`<agent>`、`<task>` 的含义（领域职责）
- [INVALID] **层次规则**：哪些元素可以包含哪些（领域职责）
- [INVALID] **必需/可选**：哪些元素是强制的（领域职责）
- [INVALID] **顺序**：元素顺序约束（领域职责）

### 7.4 混合内容

混合内容（文本 + 子元素）在协议层面语法上是有效的：

```xml
<prompt>
  你是一个具有以下技能的助手：
  <skill>规划</skill>
  <skill>分析</skill>
</prompt>
```

然而，大多数领域可能只接受纯文本或纯子元素，不接受混合。领域规范必须明确其内容模型。

---

## 8. 属性规范

### 8.1 属性语义

属性主要服务于**机器语义**：
- 类型标记（`type="json"`）
- 标识（`id="main-prompt"`）
- 配置参数

AI 可以理解属性含义，但属性针对机器处理进行了优化。

### 8.2 属性语法

属性遵循 XML 属性语法：

```xml
<element attr1="value1" attr2="value2">
```

**规则**：
- 属性名称必须是 kebab-case
- 属性值必须用引号（单引号或双引号）
- 在协议层面，属性值始终是字符串

### 8.3 保留属性

协议定义了两个所有元素都可以使用的保留属性：

#### 8.3.1 `type`

**用途**：指示元素内容的格式类型
**值**：`markdown`、`json`、`javascript`、`python`、`yaml`、`text` 或其他格式标识符
**默认值**：`text`（纯文本）

**机器语义**：告诉解析器如何处理内容
**AI 语义**：帮助 AI 理解内容性质

**示例**：
```xml
<prompt type="markdown">
# 系统提示词
你是一个助手。
</prompt>

<config type="json">
{
  "timeout": 30,
  "retry": 3
}
</config>

<script type="javascript">
function greet(name) {
  return `Hello, ${name}!`;
}
</script>

<!-- 默认：纯文本 -->
<prompt>
你是一个助手。
</prompt>
```

#### 8.3.2 `id`

**用途**：元素的唯一标识符
**值**：字符串标识符
**使用**：用于未来的引用机制（虽然在 v1.0 中未实现）

**示例**：
```xml
<prompt id="travel-system-prompt">
  你是一名旅游规划专家。
</prompt>
```

### 8.4 领域特定属性

领域可以定义自己的属性：

```xml
<!-- Agent 领域可能定义： -->
<llm
  model="gpt-4"
  api-key="sk-xxx"
  temperature="0.7"
/>
```

这些不是协议层保留属性；它们的语义由相应的领域规范定义。

### 8.5 类型系统

协议没有属性值的类型系统：
- 在协议层面，所有属性值都是字符串
- 类型解释是领域的职责

**示例**：
```xml
<llm temperature="0.7"/>
```

在协议层面：`temperature` 是字符串 `"0.7"`
在领域层面：Agent 领域将 `"0.7"` 解释为数字 0.7

---

## 9. 内容规范

### 9.1 内容类型

元素内容可以是：

1. **文本内容**：自然语言或数据
2. **子元素**：嵌套概念
3. **混合内容**：组合（语法上有效，语义上依赖领域）
4. **空**：自闭合元素

### 8.2 按类型的内容语义

内容语义取决于 `type` 属性：

| type | 机器语义 | AI 语义 | 使用场景 |
|-------------|---------|---------|---------|
| `text`（默认）| 字符串存储 | 自然语言理解 | 提示词、描述 |
| `markdown` | Markdown 解析 | 格式化文本理解 | 结构化提示词、文档 |
| `json` | JSON 解析 | 数据结构理解 | 配置、参数 |
| `javascript` | 代码解析/执行 | 代码逻辑理解 | 可执行脚本 |
| `python` | 代码解析/执行 | 代码逻辑理解 | 可执行脚本 |
| `yaml` | YAML 解析 | 数据结构理解 | 配置 |

### 9.3 空白字符处理

- 协议层：所有空白字符被保留（XML 标准）
- 领域层：可以修剪或规范化空白字符
- `type` 可能影响处理（例如，`markdown` 保留换行符）

### 9.4 特殊字符

对文本内容中的特殊字符使用 XML 转义：

**XML 转义**：
```xml
<prompt>使用 &lt;tag&gt; 进行标记 &amp; &quot;引号&quot;</prompt>
```

**代码内容**：
对于代码内容（使用 `type="javascript"`、`type="python"` 等），特殊字符如 `<`、`>`、`&` 可以直接使用而无需转义，因为解析器理解内容类型：

```xml
<script type="javascript">
if (x < 10 && y > 5) {
  console.log("Valid");
}
</script>
```

### 9.5 协议职责

协议定义：
- [VALID] `type` 属性机制
- [VALID] XML 内容规则（空白字符、转义）

协议不定义：
- [INVALID] 内容应该包含什么（领域职责）
- [INVALID] 内容验证规则（领域职责）
- [INVALID] 内容解释（领域职责）

---

## 10. 文件格式

### 10.1 文件扩展名

DPML 文档必须使用以下扩展名之一：

- **`.dpml`** - 主要的官方扩展名（推荐）
- **`.pml`** - 短别名，完全等价

两个扩展名被解析器同等对待。

**理由**：
- `.dpml` 明确且无歧义
- `.pml` 在 AI 领域提供便利且无冲突

### 10.2 MIME 类型

**主要**：`application/dpml+xml`
**备选**：`text/dpml+xml`

`+xml` 后缀表示基于 XML 的格式。

### 10.3 文档结构

#### 10.3.1 根元素

DPML 文档必须有且仅有一个根元素：

```xml
<!-- [VALID] 有效 -->
<agent>
  ...
</agent>

<!-- [INVALID] 无效：多个根元素 -->
<agent>...</agent>
<task>...</task>
```

根元素可以是领域规范定义的任何概念。

#### 10.3.2 XML 声明

XML 声明是可选的：

```xml
<!-- 如果编码不是 UTF-8，推荐使用 -->
<?xml version="1.0" encoding="UTF-8"?>
<agent>
  ...
</agent>

<!-- 也有效 -->
<agent>
  ...
</agent>
```

#### 10.3.3 注释

支持 XML 注释：

```xml
<!-- 这是注释 -->
<agent>
  <!-- 注释可以出现在任何地方 -->
  <llm model="gpt-4"/>
</agent>
```

### 10.4 最小示例

最小的有效 DPML 文档：

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>
  <prompt>你是一个助手</prompt>
</agent>
```

### 10.5 完整示例

具有所有特性的格式良好的 DPML 文档：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 旅游规划助手 -->
<agent>
  <llm
    model="gpt-4"
    api-key="sk-xxx"
  />

  <prompt id="system-prompt" type="markdown">
# 角色
你是一名张家界旅游规划专家。

## 技能
- 推荐景点
- 规划行程
- 建议住宿
  </prompt>

  <config type="json">
  {
    "temperature": 0.7,
    "max_tokens": 2000
  }
  </config>
</agent>
```

---

## 11. 验证规则

### 11.1 格式正确性

DPML 文档必须是格式良好的 XML：

- 标签正确嵌套和闭合
- 属性值用引号括起
- 文本内容中的特殊字符正确转义
- 恰好一个根元素

### 11.2 协议层验证

验证器必须检查：

1. **命名约定**：元素和属性的 kebab-case
2. **保留属性**：`type` 和 `id` 正确使用（如果存在）
3. **文件结构**：单一根元素

### 11.3 领域层验证

领域规范定义额外的验证：

- 必需元素
- 允许的子元素
- 属性要求
- 内容约束

协议层验证器应该允许任何格式良好的 DPML 文档，将领域验证留给领域特定工具。

---

## 12. 安全考虑

### 12.1 代码注入

`type="javascript"` 或 `type="python"` 的内容包含可执行代码。实现必须：

- 执行前验证代码
- 在沙箱环境中运行代码
- 执行前尊重用户同意

### 12.2 数据敏感性

像 `api-key` 这样的属性可能包含敏感信息。实现应该：

- 支持安全存储（如环境变量）
- 警告不要硬编码密钥
- 提供密钥管理最佳实践

### 12.3 XML 安全

DPML 继承了 XML 安全考虑：

- **XXE 攻击**：禁用外部实体处理
- **十亿笑攻击**：限制实体扩展
- **DTD 攻击**：DPML v1.0 不支持 DTD

### 12.4 内容信任

AI 生成或用户提供的 DPML 文档在生产环境执行前应该经过验证和审查。

---

## 13. IANA 考虑

### 13.1 媒体类型注册

**类型名称**：application
**子类型名称**：dpml+xml
**必需参数**：无
**可选参数**：charset（默认 UTF-8）
**编码考虑**：与 XML 相同
**安全考虑**：见第 11 节
**互操作性考虑**：基于 XML 1.0
**已发布规范**：本文档
**使用此媒体类型的应用**：AI 开发工具、提示词工程平台
**附加信息**：
- 魔数：与 XML 相同（`<?xml`）
- 文件扩展名：`.dpml`、`.pml`
- Macintosh 文件类型代码：TEXT

### 13.2 文件扩展名注册

**扩展名**：`.dpml`
**MIME 类型**：`application/dpml+xml`
**描述**：Deepractice 提示词标记语言文档

**扩展名**：`.pml`
**MIME 类型**：`application/dpml+xml`
**描述**：DPML 文档（短别名）

---

## 14. 参考文献

### 14.1 规范性引用

- **[XML]** 可扩展标记语言（XML）1.0（第五版），W3C 推荐标准，2008 年 11 月。
  https://www.w3.org/TR/xml/

- **[RFC2119]** Bradner, S.，"RFC 中用于表示需求级别的关键词"，BCP 14，RFC 2119，1997 年 3 月。
  https://www.rfc-editor.org/rfc/rfc2119

### 14.2 信息性引用

- **[RFC7322]** Flanagan, H. 和 S. Ginoza，"RFC 风格指南"，RFC 7322，2014 年 9 月。
  https://www.rfc-editor.org/rfc/rfc7322

- **[HTML5]** HTML5 规范，W3C 推荐标准。
  https://www.w3.org/TR/html5/

---

## 附录 A: 完整示例

### A.1 简单 Agent

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>
  <prompt>你是一个有用的编程助手。</prompt>
</agent>
```

### A.2 带 Markdown 提示词的 Agent

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>

  <prompt type="markdown">
# 角色
你是一名专注于数据科学的 Python 专家。

## 技能
- 使用 pandas 进行数据分析
- 使用 matplotlib 进行可视化
- 使用 scikit-learn 进行机器学习

## 原则
- 编写清晰、有文档的代码
- 解释你的推理
- 提供可工作的示例
  </prompt>
</agent>
```

### A.3 带 JSON 配置的 Agent

```xml
<?xml version="1.0" encoding="UTF-8"?>
<agent>
  <llm
    model="gpt-4"
    api-key="sk-xxx"
  />

  <prompt id="system">
    你是一名张家界旅游规划专家。
  </prompt>

  <config type="json">
  {
    "temperature": 0.7,
    "max_tokens": 2000,
    "top_p": 0.9
  }
  </config>
</agent>
```

### A.4 多层结构

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>

  <role>
    <personality type="markdown">
我是一个具有强大分析能力的同理心助手。
当用户感到沮丧时，我首先承认他们的感受。
当用户困惑时，我会一步步详细解释。
    </personality>

    <principle>
始终将用户体验置于技术正确性之上。
使用类比和示例解释复杂概念。
    </principle>
  </role>
</agent>
```

---

## 附录 B: ABNF 语法

DPML 的简化 ABNF 语法（基于 XML）：

```abnf
dpml-document  = [xml-decl] element

xml-decl       = "<?xml" version encoding? "?>"
version        = "version" "=" quoted-string
encoding       = "encoding" "=" quoted-string

element        = start-tag content end-tag / empty-tag

start-tag      = "<" element-name *attribute ">"
end-tag        = "</" element-name ">"
empty-tag      = "<" element-name *attribute "/>"

element-name   = lowercase-word *("-" lowercase-word)
lowercase-word = 1*ALPHA

attribute      = attribute-name "=" quoted-string
attribute-name = lowercase-word *("-" lowercase-word)

content        = *( text / element / comment )

text           = 1*CHAR  ; 排除 < 和 &
comment        = "<!--" *CHAR "-->"

quoted-string  = DQUOTE *CHAR DQUOTE / SQUOTE *CHAR SQUOTE
```

**注意**：这是简化表示。完整的 XML 语法适用。

---

## 附录 C: 为什么选择 XML 而非 YAML/JSON

本附录从 DPML 三方 Prompt 协议设计的角度，深入比较 XML、YAML 和 JSON 格式。

### C.1 语义维度问题

设计三方协议的根本挑战在于，不同的利益相关方需要从同一份文档中获取不同类型的信息。格式必须提供足够的**语义维度**来同时表达所有三种类型而互不干扰。

#### 语义维度比较

| 格式 | 语义维度 | 可表达内容 |
|------|---------|-----------|
| **YAML** | 2（键、值） | 仅名称和数据 |
| **JSON** | 2（键、值） | 仅名称和数据 |
| **XML** | 4（标签、属性、内容、结构） | 概念、配置、内容和层级 |

### C.2 为什么 YAML 不适合三方 Prompt

#### 问题 1：缩进作为语义

在 YAML 中，缩进承载语义含义，给 AI 造成认知负担：

```yaml
agent:
  llm:
    model: gpt-4
    temperature: 0.7
  prompt: |
    你是助手
```

**AI 的处理负担**：
- 必须数空格来确定层级（`agent` → `llm` → `model`）
- 缩进错误会破坏结构（2 个空格 vs 4 个空格改变含义）
- AI 需要在脑海中维护"缩进栈"

**XML 等效（无缩进负担）**：

```xml
<agent>
  <llm model="gpt-4" temperature="0.7"/>
  <prompt>你是助手</prompt>
</agent>
```

缩进纯粹是为了人类可读性；结构在标签中是明确的。

#### 问题 2：没有独立的内容空间

YAML 没有与"值"分离的"内容"概念：

```yaml
prompt:
  type: markdown
  content: |
    你是助手。
    你擅长旅行规划。
```

实际的 prompt 内容只是另一个 `content:` 键值对。AI 将其视为与 `type:` 结构等同，产生噪音。

**XML 的内容空间**：

```xml
<prompt type="markdown">
  你是助手。
  你擅长旅行规划。
</prompt>
```

内容存在于自己的语义空间中，与属性明确分离。

#### 问题 3：所有信息在同一平面

在 YAML 中，机器配置和 AI 指令存在于同一概念层级：

```yaml
agent:
  llm:
    model: gpt-4         # 机器配置
    temperature: 0.7     # 机器配置
  prompt: |              # AI 指令
    你是助手
  metadata:
    version: "2.0"       # 人类元数据
```

`model`（给计算机）、`prompt`（给 AI）和 `metadata`（给人类）之间没有固有区别。它们都只是键。

**XML 的分层语义**：

```xml
<agent>
  <!-- 机器领域：属性 -->
  <llm model="gpt-4" temperature="0.7"/>

  <!-- AI 领域：内容 -->
  <prompt>你是助手</prompt>

  <!-- 人类领域：元数据 + 结构 -->
  <metadata version="2.0"/>
</agent>
```

每个利益相关方都有专用的语义空间。

#### 问题 4：可视化结构差

YAML 本质上是扁平的，难以渲染为视觉层级：

```yaml
# 如何将其映射到 UI 组件？
agent:
  llm:
    model: gpt-4
  tools:
    - name: search
      endpoint: /api/search
    - name: calc
```

没有到视觉元素（卡片、面板、区块）的自然映射。

**XML 的 DOM 自然映射到 UI**：

```xml
<agent>                    → 卡片："Agent"
  <llm model="gpt-4"/>     →   区块："LLM 配置"
  <tools>                  →   区块："工具"
    <tool name="search"/>  →     项目："search"
    <tool name="calc"/>    →     项目："calc"
  </tools>
</agent>
```

每个元素都是潜在的 UI 组件。

### C.3 为什么 JSON 有同样的局限

JSON 遇到与 YAML 类似的问题，尽管有明确的括号：

```json
{
  "agent": {
    "llm": {
      "model": "gpt-4",
      "temperature": 0.7
    },
    "prompt": "你是助手",
    "metadata": {
      "version": "2.0"
    }
  }
}
```

**问题**：
- 只有 2 个语义维度（键 + 值）
- 没有独立的内容空间（prompt 是像其他任何值一样的字符串值）
- 括号和引号噪音增加认知负担
- 与 YAML 一样的扁平层级

### C.4 为什么 XML 成功

#### 优势 1：四个独立的语义维度

```xml
<concept-name attribute="value">
  内容文本
</concept-name>
```

**四个维度**：
1. **标签名**：概念身份（`<prompt>` 表示"这是一个 prompt"）
2. **属性**：机器配置（键值对）
3. **内容**：AI 的自然表达空间
4. **结构**：人类可见的层级（DOM 树）

#### 优势 2：清晰的职责分离

| 维度 | 主要消费者 | 次要消费者 | 示例 |
|------|-----------|-----------|------|
| **标签** | 人类（理解结构） | 计算机和 AI（上下文） | `<prompt>`、`<tool>` |
| **属性** | 计算机（解析配置） | AI（理解元数据） | `model="gpt-4"` |
| **内容** | AI（理解意图） | 人类（阅读定义） | `你是助手` |
| **结构** | 人类（观察） | 计算机（验证） | 嵌套、层级 |

#### 优势 3：无需重构的扩展性

添加新信息不需要改变文档结构：

**YAML**：
```yaml
# 原始
prompt:
  type: markdown
  content: 你是助手

# 添加元数据需要重构
prompt:
  type: markdown
  metadata:           # 新层级！
    author: 张三
    created: 2025-01-01
  content: 你是助手  # 下移了
```

**XML**：
```xml
<!-- 原始 -->
<prompt type="markdown">你是助手</prompt>

<!-- 添加元数据 - 无需重构 -->
<prompt type="markdown" author="张三" created="2025-01-01">
  你是助手
</prompt>

<!-- 或作为子元素 -->
<prompt type="markdown">
  <metadata author="张三" created="2025-01-01"/>
  你是助手
</prompt>
```

#### 优势 4：可观测的 AI 系统

XML 的 DOM 结构实现实时可观测性：

**开发（静态定义）**：
```xml
<agent>
  <llm model="gpt-4"/>
  <prompt>你是助手</prompt>
</agent>
```

**运行时（动态状态注入）**：
```xml
<agent status="running" uptime="3600s">
  <llm model="gpt-4" tokens-used="1520" requests="23"/>
  <prompt version="2.0"/>
  <tools>
    <tool name="search" calls="15" latency="120ms"/>
  </tools>
</agent>
```

**可视化（自动渲染）**：
```
┌─ Agent ──────────────────────┐
│ 状态: 运行中 (1小时)          │
│ 模型:  GPT-4                 │
│ Token: 1,520 / 10,000        │
│                               │
│ 工具:                         │
│ • search  15次  120ms        │
└───────────────────────────────┘
```

YAML/JSON 的扁平结构难以实现这一点。

### C.5 认知负担比较

从 AI 的角度：

**生成 YAML**：
```yaml
agent:
  llm:
    model: gpt-4    # 必须维护缩进层级（4个空格）
  prompt: |         # 必须记住使用 |
    内容在这里      # 必须正确缩进内容
```

AI 心理清单：
- ✗ 为每个层级数空格
- ✗ 记住当前缩进深度
- ✗ 对多行字符串使用 `|`
- ✗ 确保内容缩进匹配

**生成 XML**：
```xml
<agent>
  <llm model="gpt-4"/>
  <prompt>
    内容在这里
  </prompt>
</agent>
```

AI 心理清单：
- ✓ 写 `<tag>`
- ✓ 写 `</tag>`
- ✓ 缩进无关紧要

XML 的显式闭合标签充当"错误检测"——AI 知道结构何时完成。

### C.6 总结：格式决策矩阵

| 需求 | YAML | JSON | XML |
|------|------|------|-----|
| **三方 Prompt** | ✗ | ✗ | ✓ |
| **语义维度** | 2 | 2 | 4 |
| **独立内容空间** | ✗ | ✗ | ✓ |
| **视觉层级** | ✗ | ✗ | ✓ |
| **低 AI 认知负担** | ✗ | △ | ✓ |
| **扩展性** | △ | △ | ✓ |
| **可观测性** | ✗ | ✗ | ✓ |

**结论**：选择 XML 不是因为它"熟悉"或"成熟"——而是因为它是**唯一具有足够语义维度**来同时服务计算机、AI 和人类的格式。

DPML 的三方协议从根本上需要四个语义空间（标签/属性/内容/结构），只有 XML 能提供它们。

---

## 作者地址

**姜山（Sean Jiang）**
Deepractice.ai
邮箱：sean@deepractice.ai
网站：https://deepractice.ai

---

**DPML 协议规范 v1.0 结束**
