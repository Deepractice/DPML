# DPML 协议规范 v1.0

**状态**: 草案  
**日期**: 2025年10月  
**作者**: 姜山 (Deepractice.ai)

---

## 摘要

本文档定义了 Deepractice 提示词标记语言（DPML）协议 1.0 版本。DPML 是一种基于 XML 的标记语言，旨在以声明式方式定义 AI 应用。该协议建立了基础语法和语义，使人类、AI 系统和计算机能够有效协作，创建和理解 AI 应用定义。

DPML 遵循两个核心设计原则："约而不束"和"最小化认知负担"，确保语言提供结构的同时不限制 AI 的灵活性，并为人类和 AI 系统保持较低的心智开销。

---

## 目录

1. [引言](#1-引言)
2. [术语](#2-术语)
3. [设计原则](#3-设计原则)
4. [协议概述](#4-协议概述)
5. [语法规范](#5-语法规范)
6. [元素规范](#6-元素规范)
7. [属性规范](#7-属性规范)
8. [内容规范](#8-内容规范)
9. [文件格式](#9-文件格式)
10. [验证规则](#10-验证规则)
11. [安全考虑](#11-安全考虑)
12. [IANA 考虑](#12-iana-考虑)
13. [参考文献](#13-参考文献)
14. [附录 A: 完整示例](#附录-a-完整示例)
15. [附录 B: ABNF 语法](#附录-b-abnf-语法)

---

## 1. 引言

### 1.1 动机

传统的 AI 应用开发需要深入理解模型 API、提示词工程技术和复杂的编程。DPML 通过提供声明式标记语言改变了这一现状：

- 使用熟悉的 XML-like 语法
- 采用人类和 AI 都能理解的共识概念
- 将结构（给计算机）与语义（给 AI）分离
- 通过简洁性最小化认知负担

### 1.2 目标

DPML 协议旨在：

1. **建立基础**：定义 AI 应用标记的元语言
2. **实现互操作性**：提供工具可以解析和生成的标准格式
3. **支持可扩展性**：允许领域特定扩展，同时保持核心一致性
4. **优化双重理解**：同时服务于机器解析和 AI 理解

### 1.3 范围

本规范定义：

- **核心语法**：元素、属性和内容结构
- **元语义**：概念如何表达和组织
- **文件格式**：文档结构和约定
- **验证规则**：格式正确性和结构有效性

本规范不定义：

- **领域语义**：`<agent>`、`<task>` 等的具体含义（由领域规范定义）
- **运行时行为**：元素如何执行或解释
- **扩展机制**：详细的插件或命名空间系统（预留给未来版本）

### 1.4 需求语言

本文档中的关键词"必须（MUST）"、"禁止（MUST NOT）"、"要求（REQUIRED）"、"应当（SHALL）"、"不应（SHALL NOT）"、"应该（SHOULD）"、"不应该（SHOULD NOT）"、"推荐（RECOMMENDED）"、"可以（MAY）"和"可选（OPTIONAL）"按照 RFC 2119 中的描述进行解释。

---

## 2. 术语

### 2.1 核心术语

**DPML 文档**：包含 DPML 标记的文件，通常使用 `.dpml` 或 `.pml` 扩展名。

**概念（Concept）**：由元素标签表示的语义单元。概念是共识术语（如 `role`、`agent`、`task`），承载人类和 AI 无需额外解释即可理解的含义。

**元素（Element）**：表示概念的 XML 标签结构。元素有开始标签、结束标签（或自闭合），可以包含属性和内容。

**属性（Attribute）**：附加到元素的键值对，主要服务于机器语义（解析、类型标记、标识）。

**内容（Content）**：元素内的文本或子元素，根据上下文服务于 AI 语义（自然语言）或机器语义（结构化数据）。

**保留属性（Reserved Attribute）**：在协议层面定义的、所有领域都可以使用的属性（当前为：`type`、`id`）。

**领域（Domain）**：DPML 的专门化区域，具有特定的元素定义（如 Agent 领域、Task 领域）。

### 2.2 设计原则术语

**约而不束**：建立结构和约定（约），但不限制 AI 的逻辑灵活性（不束）。

**认知负担（Cognitive Load）**：理解和处理信息所需的心智努力，DPML 通过简洁性和共识概念最小化这一负担。

**共识概念（Consensus Concept）**：具有广泛理解含义、无需额外解释的术语（如 `role`、`personality`、`agent`）。

**双重语义（Dual Semantics）**：每个语法元素同时服务于机器语义（解析、验证）和 AI 语义（理解、推理）。

---

## 3. 设计原则

### 3.1 约而不束原则

**核心哲学**：提供结构和方向，但不限制 AI 的创造性和适应能力。

**我们约束的内容**：
- 结构：XML 标签系统、层次结构、命名约定
- 语法：kebab-case 命名、保留属性
- 共识：使用既定概念，不发明术语

**我们不束缚的内容**：
- 逻辑：内容中没有 if-else 控制流
- 表达：内容中的自然语言自由
- 行为：原则优于规则，意图优于过程

**示例**：

```xml
<!-- [INVALID] 错误：束缚逻辑 -->
<rules>
  <if condition="user_angry">
    <response>我为给您带来的不便道歉</response>
  </if>
  <if condition="user_confused">
    <response>让我一步步解释</response>
  </if>
</rules>

<!-- [VALID] 正确：约束结构，不束缚逻辑 -->
<personality>
我是一个有同理心的助手。当用户不高兴时，我首先关注他们的情绪。
当用户困惑时，我会耐心解释。我始终保持专业和友好。
</personality>
```

### 3.2 最小化认知负担原则

**核心哲学**：AI 的注意力是稀缺资源。复杂规则会消耗认知带宽。

**证据**：实证测试显示：
- OpenAPI 规范（高认知负担）：30%+ 错误率
- Markdown 文档（低认知负担）：<10% 错误率
- DPML（最小认知负担）：<5% 错误率

**策略**：

1. **使用共识概念**：像 `role`、`agent`、`personality` 这样的术语具有内在含义
   ```xml
   <!-- 低熵：概念即定义 -->
   <role>
     <personality>...</personality>
   </role>

   <!-- 高熵：需要解释 -->
   <xuanwu>
     <qiankun>...</qiankun>
   </xuanwu>
   ```

2. **最小化核心概念**：将协议层面的概念保持在 5 个以下
   - 元素命名规则：1 个（kebab-case）
   - 保留属性：2 个（`type`、`id`）
   - 核心结构规则：2 个（基于 XML、单一根元素）

3. **分层复杂度**：结构（简单）+ 内容（灵活）

### 3.3 共识概念优先原则

**核心哲学**：在定义领域概念（元素名称）时，必须严格考证，选择共时性最大、最精准、语义性最强、最富有内涵的概念。

**四个选择标准**：

1. **共时性**
   - 在当前时代、当前领域有最广泛的共识
   - 跨文化、跨语言都能理解
   - 不使用过时或小众的术语

2. **精准性**
   - 概念边界清晰
   - 不会产生歧义
   - 一个概念对应一个明确的语义

3. **语义性**
   - 词汇本身承载丰富的语义
   - 不需要额外解释就能理解
   - AI 和人类都能直接理解

4. **内涵性**
   - 概念背后有深厚的理论基础
   - 承载着领域的最佳实践
   - 隐含了结构和关系

**信息论基础**：

共识概念是**压缩的知识**：

```
概念 "role" 的信息
├─ 显式信息：4个字母 "r-o-l-e"
└─ 隐式信息（免费）：
   ├─ 职责框架
   ├─ 能力边界
   ├─ 行为模式
   └─ 社会关系

总信息熵：极低（概念即定义）
```

自造词汇是**高熵**：

```
概念 "lero" 的信息
├─ 显式信息：4个字母 "l-e-r-o"
└─ 隐式信息：无
└─ 需要额外解释：
   ├─ "lero 是什么？"
   ├─ "lero 包含什么？"
   ├─ "lero 如何使用？"
   └─ 至少需要 50-100 个词解释

总信息熵：极高
```

**Token 经济学**：

使用共识概念节约 ~90% token 成本：

| 方案 | Token 成本 | AI 理解 | 信息传递 |
|------|-----------|---------|---------|
| 共识概念（`role`）| ~10 tokens | 即时、准确 | 完整、清晰 |
| 自造词汇（`lero`）| ~100+ tokens | 需要推理 | 需要解释 |

**决策框架**：

定义新的领域概念时：

```
Step 1: 识别概念需求
Step 2: 搜索共识概念
        ├─ 查询该领域的标准术语
        ├─ 参考权威文献、框架
        └─ 询问领域专家
Step 3: 评估候选概念
        ├─ 共时性：在当前时代是否广泛使用？
        ├─ 精准性：是否有明确边界？
        ├─ 语义性：是否自带含义？
        └─ 内涵性：是否承载深层知识？
Step 4: 计算信息熵成本
        └─ 需要多少词汇解释这个概念？
Step 5: 决策
        ├─ 所有标准 + → 采用
        ├─ 任一标准 - → 拒绝
        └─ 找不到合适概念 → 重新审视需求
```

**示例**：

[VALID] **好的选择**：
- `role`、`agent`、`personality`、`task`、`principle` - 都是各项标准  的共识概念

[INVALID] **糟糕的选择**：
- `lero` - 自造词，无共识（成本：50+ 词解释）
- `xuanwu` - 文化特定，非通用（成本：30+ 词）
- `thing` - 过于泛化，不精准（成本：20+ 词）

**验证方法**：

如果一个概念：
- 需要 >10 个词解释
- AI 需要额外上下文才能理解
- 跨文化、跨语言无法直接理解

→ 不是好的共识概念

**核心洞察**：

> **共识概念 = 免费的提示词**
>
> 选择概念 = 选择信息密度
>
> 好的概念 = 压缩的知识
>
> 自造概念 = 信息熵灾难

这个原则确保 DPML 作为标记语言的**经济性**和**高效性**，在词汇层面应用奥卡姆剃刀原理。

### 3.4 双重语义原则

每个语法元素服务于两个受众：

**机器语义**：
- 结构化、可解析、可验证
- 面向：编译器、验证器、工具
- 关注：正确性、效率

**AI 语义**：
- 概念化、上下文化、可推断
- 面向：大语言模型
- 关注：理解、推理

**元素平衡**：两种语义权重相等
**属性平衡**：偏重机器语义，轻量 AI 语义
**内容平衡**：由 `type` 决定

---

## 4. 协议概述

### 4.1 基础

DPML 是 **XML 1.0 的子集**，添加了特定的约定和约束：

- **基于**：XML 1.0 规范
- **增加**：命名约定、保留属性、元语义规则
- **移除**：DTD、XML Schema、处理指令、实体（为了简洁）

### 4.2 架构

```
┌─────────────────────────────────────────────┐
│           DPML 协议（元层）                 │
│  • 语法规则                                 │
│  • 元素/属性/内容 元语义                    │
│  • 保留属性                                 │
│  • 文件格式约定                             │
└─────────────────────────────────────────────┘
                    ▼
┌─────────────────────────────────────────────┐
│           领域规范                          │
│  • Agent 领域（对话式 AI）                  │
│  • Task 领域（状态机任务）                  │
│  • Role 领域（AI 人格）                     │
│  • Workflow 领域（工作流编排）              │
└─────────────────────────────────────────────┘
```

### 4.3 层次职责

**协议层**（本文档）：
- 如何定义概念（语法、结构）
- 元语义（元素/属性/内容的一般含义）
- 验证规则（格式正确性）

**领域层**（独立规范）：
- 存在哪些概念（如 `<agent>` 等特定元素）
- 领域语义（`<agent>` 的含义和要求）
- 领域特定验证

---

## 5. 语法规范

### 5.1 基本结构

DPML 文档必须是格式良好的 XML：

```xml
<concept-name attribute-name="attribute-value">
  内容或子元素
</concept-name>
```

### 5.2 命名约定

#### 5.2.1 元素名称

元素名称必须遵循 **kebab-case**：

- 全部小写字母
- 单词之间用连字符分隔
- 不使用下划线、不使用驼峰命名、不使用帕斯卡命名

**有效**：`<agent>`、`<travel-planner>`、`<api-config>`
**无效**：`<Agent>`、`<travelPlanner>`、`<api_config>`

**理由**：
- 与 HTML 传统一致
- 对人类和 AI 都可读
- 避免大小写敏感问题

#### 5.2.2 属性名称

属性名称必须遵循 **kebab-case**（与元素相同）：

**有效**：`api-key="..."`、`type="..."`、`model-name="..."`
**无效**：`apiKey="..."`、`API_KEY="..."`、`ModelName="..."`

### 5.3 字符编码

DPML 文档应该使用 UTF-8 编码。如果使用其他编码，应该包含 XML 声明：

```xml
<?xml version="1.0" encoding="UTF-8"?>
```

### 5.4 空白字符

- 内容中的空白字符会被保留（按照 XML 规范）
- 前导/尾随空白字符的处理由领域规范决定
- 属性值中的空白字符会被保留

---

## 6. 元素规范

### 6.1 元素即概念

在 DPML 中，元素表示**概念**而非仅仅是结构标记。

**概念的特征**：
- **完备性**：自包含的语义单元
- **共识性**：广泛理解的术语（非发明）
- **清晰性**：明确的边界和组成

**示例**：
```xml
<role>           <!-- 概念：角色定义 -->
  <personality>  <!-- 概念：人格特征 -->
    ...
  </personality>
</role>
```

### 6.2 元素结构

元素可以是：

1. **容器元素**：带有开始和结束标签
   ```xml
   <agent>
     <llm model="gpt-4"/>
     <prompt>你是一个助手</prompt>
   </agent>
   ```

2. **自闭合元素**：用于叶子概念
   ```xml
   <llm model="gpt-4" api-key="sk-xxx"/>
   ```

3. **文本内容元素**：仅包含文本内容
   ```xml
   <prompt>你是一个有用的助手</prompt>
   ```

### 6.3 协议层规则

协议定义：
- [VALID] **命名约定**：kebab-case
- [VALID] **概念原则**：使用共识术语

协议不定义：
- [INVALID] **特定元素**：`<agent>`、`<task>` 的含义（领域职责）
- [INVALID] **层次规则**：哪些元素可以包含哪些（领域职责）
- [INVALID] **必需/可选**：哪些元素是强制的（领域职责）
- [INVALID] **顺序**：元素顺序约束（领域职责）

### 6.4 混合内容

混合内容（文本 + 子元素）在协议层面语法上是有效的：

```xml
<prompt>
  你是一个具有以下技能的助手：
  <skill>规划</skill>
  <skill>分析</skill>
</prompt>
```

然而，大多数领域可能只接受纯文本或纯子元素，不接受混合。领域规范必须明确其内容模型。

---

## 7. 属性规范

### 7.1 属性语义

属性主要服务于**机器语义**：
- 类型标记（`type="json"`）
- 标识（`id="main-prompt"`）
- 配置参数

AI 可以理解属性含义，但属性针对机器处理进行了优化。

### 7.2 属性语法

属性遵循 XML 属性语法：

```xml
<element attr1="value1" attr2="value2">
```

**规则**：
- 属性名称必须是 kebab-case
- 属性值必须用引号（单引号或双引号）
- 在协议层面，属性值始终是字符串

### 7.3 保留属性

协议定义了两个所有元素都可以使用的保留属性：

#### 7.3.1 `type`

**用途**：指示元素内容的格式类型
**值**：`markdown`、`json`、`javascript`、`python`、`yaml`、`text` 或其他格式标识符
**默认值**：`text`（纯文本）

**机器语义**：告诉解析器如何处理内容
**AI 语义**：帮助 AI 理解内容性质

**示例**：
```xml
<prompt type="markdown">
# 系统提示词
你是一个助手。
</prompt>

<config type="json">
{
  "timeout": 30,
  "retry": 3
}
</config>

<script type="javascript">
function greet(name) {
  return `Hello, ${name}!`;
}
</script>

<!-- 默认：纯文本 -->
<prompt>
你是一个助手。
</prompt>
```

#### 7.3.2 `id`

**用途**：元素的唯一标识符
**值**：字符串标识符
**使用**：用于未来的引用机制（虽然在 v1.0 中未实现）

**示例**：
```xml
<prompt id="travel-system-prompt">
  你是一名旅游规划专家。
</prompt>
```

### 7.4 领域特定属性

领域可以定义自己的属性：

```xml
<!-- Agent 领域可能定义： -->
<llm
  model="gpt-4"
  api-key="sk-xxx"
  temperature="0.7"
/>
```

这些不是协议层保留属性；它们的语义由相应的领域规范定义。

### 7.5 类型系统

协议没有属性值的类型系统：
- 在协议层面，所有属性值都是字符串
- 类型解释是领域的职责

**示例**：
```xml
<llm temperature="0.7"/>
```

在协议层面：`temperature` 是字符串 `"0.7"`
在领域层面：Agent 领域将 `"0.7"` 解释为数字 0.7

---

## 8. 内容规范

### 8.1 内容类型

元素内容可以是：

1. **文本内容**：自然语言或数据
2. **子元素**：嵌套概念
3. **混合内容**：组合（语法上有效，语义上依赖领域）
4. **空**：自闭合元素

### 8.2 按类型的内容语义

内容语义取决于 `type` 属性：

| type | 机器语义 | AI 语义 | 使用场景 |
|-------------|---------|---------|---------|
| `text`（默认）| 字符串存储 | 自然语言理解 | 提示词、描述 |
| `markdown` | Markdown 解析 | 格式化文本理解 | 结构化提示词、文档 |
| `json` | JSON 解析 | 数据结构理解 | 配置、参数 |
| `javascript` | 代码解析/执行 | 代码逻辑理解 | 可执行脚本 |
| `python` | 代码解析/执行 | 代码逻辑理解 | 可执行脚本 |
| `yaml` | YAML 解析 | 数据结构理解 | 配置 |

### 8.3 空白字符处理

- 协议层：所有空白字符被保留（XML 标准）
- 领域层：可以修剪或规范化空白字符
- `type` 可能影响处理（例如，`markdown` 保留换行符）

### 8.4 特殊字符

对文本内容中的特殊字符使用 XML 转义：

**XML 转义**：
```xml
<prompt>使用 &lt;tag&gt; 进行标记 &amp; &quot;引号&quot;</prompt>
```

**代码内容**：
对于代码内容（使用 `type="javascript"`、`type="python"` 等），特殊字符如 `<`、`>`、`&` 可以直接使用而无需转义，因为解析器理解内容类型：

```xml
<script type="javascript">
if (x < 10 && y > 5) {
  console.log("Valid");
}
</script>
```

### 8.5 协议职责

协议定义：
- [VALID] `type` 属性机制
- [VALID] XML 内容规则（空白字符、转义）

协议不定义：
- [INVALID] 内容应该包含什么（领域职责）
- [INVALID] 内容验证规则（领域职责）
- [INVALID] 内容解释（领域职责）

---

## 9. 文件格式

### 9.1 文件扩展名

DPML 文档必须使用以下扩展名之一：

- **`.dpml`** - 主要的官方扩展名（推荐）
- **`.pml`** - 短别名，完全等价

两个扩展名被解析器同等对待。

**理由**：
- `.dpml` 明确且无歧义
- `.pml` 在 AI 领域提供便利且无冲突

### 9.2 MIME 类型

**主要**：`application/dpml+xml`
**备选**：`text/dpml+xml`

`+xml` 后缀表示基于 XML 的格式。

### 9.3 文档结构

#### 9.3.1 根元素

DPML 文档必须有且仅有一个根元素：

```xml
<!-- [VALID] 有效 -->
<agent>
  ...
</agent>

<!-- [INVALID] 无效：多个根元素 -->
<agent>...</agent>
<task>...</task>
```

根元素可以是领域规范定义的任何概念。

#### 9.3.2 XML 声明

XML 声明是可选的：

```xml
<!-- 如果编码不是 UTF-8，推荐使用 -->
<?xml version="1.0" encoding="UTF-8"?>
<agent>
  ...
</agent>

<!-- 也有效 -->
<agent>
  ...
</agent>
```

#### 9.3.3 注释

支持 XML 注释：

```xml
<!-- 这是注释 -->
<agent>
  <!-- 注释可以出现在任何地方 -->
  <llm model="gpt-4"/>
</agent>
```

### 9.4 最小示例

最小的有效 DPML 文档：

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>
  <prompt>你是一个助手</prompt>
</agent>
```

### 9.5 完整示例

具有所有特性的格式良好的 DPML 文档：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 旅游规划助手 -->
<agent>
  <llm
    model="gpt-4"
    api-key="sk-xxx"
  />

  <prompt id="system-prompt" type="markdown">
# 角色
你是一名张家界旅游规划专家。

## 技能
- 推荐景点
- 规划行程
- 建议住宿
  </prompt>

  <config type="json">
  {
    "temperature": 0.7,
    "max_tokens": 2000
  }
  </config>
</agent>
```

---

## 10. 验证规则

### 10.1 格式正确性

DPML 文档必须是格式良好的 XML：

- 标签正确嵌套和闭合
- 属性值用引号括起
- 文本内容中的特殊字符正确转义
- 恰好一个根元素

### 10.2 协议层验证

验证器必须检查：

1. **命名约定**：元素和属性的 kebab-case
2. **保留属性**：`type` 和 `id` 正确使用（如果存在）
3. **文件结构**：单一根元素

### 10.3 领域层验证

领域规范定义额外的验证：

- 必需元素
- 允许的子元素
- 属性要求
- 内容约束

协议层验证器应该允许任何格式良好的 DPML 文档，将领域验证留给领域特定工具。

---

## 11. 安全考虑

### 11.1 代码注入

`type="javascript"` 或 `type="python"` 的内容包含可执行代码。实现必须：

- 执行前验证代码
- 在沙箱环境中运行代码
- 执行前尊重用户同意

### 11.2 数据敏感性

像 `api-key` 这样的属性可能包含敏感信息。实现应该：

- 支持安全存储（如环境变量）
- 警告不要硬编码密钥
- 提供密钥管理最佳实践

### 11.3 XML 安全

DPML 继承了 XML 安全考虑：

- **XXE 攻击**：禁用外部实体处理
- **十亿笑攻击**：限制实体扩展
- **DTD 攻击**：DPML v1.0 不支持 DTD

### 11.4 内容信任

AI 生成或用户提供的 DPML 文档在生产环境执行前应该经过验证和审查。

---

## 12. IANA 考虑

### 12.1 媒体类型注册

**类型名称**：application
**子类型名称**：dpml+xml
**必需参数**：无
**可选参数**：charset（默认 UTF-8）
**编码考虑**：与 XML 相同
**安全考虑**：见第 11 节
**互操作性考虑**：基于 XML 1.0
**已发布规范**：本文档
**使用此媒体类型的应用**：AI 开发工具、提示词工程平台
**附加信息**：
- 魔数：与 XML 相同（`<?xml`）
- 文件扩展名：`.dpml`、`.pml`
- Macintosh 文件类型代码：TEXT

### 12.2 文件扩展名注册

**扩展名**：`.dpml`
**MIME 类型**：`application/dpml+xml`
**描述**：Deepractice 提示词标记语言文档

**扩展名**：`.pml`
**MIME 类型**：`application/dpml+xml`
**描述**：DPML 文档（短别名）

---

## 13. 参考文献

### 13.1 规范性引用

- **[XML]** 可扩展标记语言（XML）1.0（第五版），W3C 推荐标准，2008 年 11 月。
  https://www.w3.org/TR/xml/

- **[RFC2119]** Bradner, S.，"RFC 中用于表示需求级别的关键词"，BCP 14，RFC 2119，1997 年 3 月。
  https://www.rfc-editor.org/rfc/rfc2119

### 13.2 信息性引用

- **[RFC7322]** Flanagan, H. 和 S. Ginoza，"RFC 风格指南"，RFC 7322，2014 年 9 月。
  https://www.rfc-editor.org/rfc/rfc7322

- **[HTML5]** HTML5 规范，W3C 推荐标准。
  https://www.w3.org/TR/html5/

---

## 附录 A: 完整示例

### A.1 简单 Agent

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>
  <prompt>你是一个有用的编程助手。</prompt>
</agent>
```

### A.2 带 Markdown 提示词的 Agent

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>

  <prompt type="markdown">
# 角色
你是一名专注于数据科学的 Python 专家。

## 技能
- 使用 pandas 进行数据分析
- 使用 matplotlib 进行可视化
- 使用 scikit-learn 进行机器学习

## 原则
- 编写清晰、有文档的代码
- 解释你的推理
- 提供可工作的示例
  </prompt>
</agent>
```

### A.3 带 JSON 配置的 Agent

```xml
<?xml version="1.0" encoding="UTF-8"?>
<agent>
  <llm
    model="gpt-4"
    api-key="sk-xxx"
  />

  <prompt id="system">
    你是一名张家界旅游规划专家。
  </prompt>

  <config type="json">
  {
    "temperature": 0.7,
    "max_tokens": 2000,
    "top_p": 0.9
  }
  </config>
</agent>
```

### A.4 多层结构

```xml
<agent>
  <llm model="gpt-4" api-key="sk-xxx"/>

  <role>
    <personality type="markdown">
我是一个具有强大分析能力的同理心助手。
当用户感到沮丧时，我首先承认他们的感受。
当用户困惑时，我会一步步详细解释。
    </personality>

    <principle>
始终将用户体验置于技术正确性之上。
使用类比和示例解释复杂概念。
    </principle>
  </role>
</agent>
```

---

## 附录 B: ABNF 语法

DPML 的简化 ABNF 语法（基于 XML）：

```abnf
dpml-document  = [xml-decl] element

xml-decl       = "<?xml" version encoding? "?>"
version        = "version" "=" quoted-string
encoding       = "encoding" "=" quoted-string

element        = start-tag content end-tag / empty-tag

start-tag      = "<" element-name *attribute ">"
end-tag        = "</" element-name ">"
empty-tag      = "<" element-name *attribute "/>"

element-name   = lowercase-word *("-" lowercase-word)
lowercase-word = 1*ALPHA

attribute      = attribute-name "=" quoted-string
attribute-name = lowercase-word *("-" lowercase-word)

content        = *( text / element / comment )

text           = 1*CHAR  ; 排除 < 和 &
comment        = "<!--" *CHAR "-->"

quoted-string  = DQUOTE *CHAR DQUOTE / SQUOTE *CHAR SQUOTE
```

**注意**：这是简化表示。完整的 XML 语法适用。

---

## 作者地址

**姜山（Sean Jiang）**
Deepractice.ai
邮箱：sean@deepractice.ai
网站：https://deepractice.ai

---

**DPML 协议规范 v1.0 结束**
