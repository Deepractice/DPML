# DPML 元规范

## 1. 概述

DPML (Deepractice Prompt Markup Language) 是一种元标记语言框架，专为大语言模型交互设计。它定义了一套核心规则和扩展机制，不限定具体标签或实现细节，仅提供统一的结构原则和扩展框架。DPML采用XML结构与Markdown内容相结合的方式，提供结构化、模块化和可复用的编写范式。

## 2. 核心原则

### 2.1 文档结构

DPML文档使用XML格式，需要一个根标签作为入口点，但不限定根标签的具体名称。DPML作为元规范不关心具体实现层的标签名称和嵌套结构。

```xml
<!-- 示例结构，实际标签名由具体实现决定 -->
<root-tag version="1.0">
  <!-- 功能标签 -->
</root-tag>
```

### 2.2 设计原则

#### 2.2.1 属性与内容分离

DPML的核心设计原则之一是严格分离结构与内容：

- **属性(Attributes)**：专注于标签的结构、引用和标识等元信息
- **内容(Content)**：专注于实质性内容，统一使用Markdown格式

这种分离使DPML既保持了XML的结构化优势，又利用了Markdown的内容表达能力，为LLM提供了理想的输入格式。

#### 2.2.2 约定大于配置

DPML遵循"约定大于配置"原则，提供合理默认值和隐式行为，减少显式配置需求。实现层可以定义自己的处理约定，但建议保持简单直观。

#### 2.2.3 可组合性与可扩展性

DPML鼓励模块化、可组合和可扩展设计：
- 通过标签继承机制支持标签复用
- 支持跨文档引用实现模板化
- 允许通过插件机制扩展功能

## 3. 通用属性系统

DPML定义了一套通用属性系统，作为基础规范：

### 3.1 基础属性

| 属性 | 适用范围 | 格式 | 说明 | 实现状态 |
|------|---------|------|------|---------|
| **id** | 所有标签 | 字符串 | 提供标签的唯一标识符，便于引用。命名规则：字母开头，允许字母、数字、下划线、连字符。 | ✅ 已实现，包括ID唯一性验证 |
| **version** | 根标签 | 主版本.次版本 | 指示DPML规范版本，影响解析规则。如"1.0"、"2.1"。 | ⏳ 保留属性，第一期暂不实现版本兼容性检查 |
| **lang** | 根标签 | ISO语言代码 | 指定语言，影响内容解释。如"zh-CN"、"en-US"。 | ⚪ 第一期仅记录，不影响处理行为 |

### 3.2 继承属性

| 属性 | 适用范围 | 格式 | 说明 | 实现状态 |
|------|---------|------|------|---------|
| **extends** | 所有标签 | URI或ID引用 | 从其他标签继承定义，实现复用。可引用本地文件、远程文件或文档内ID。 | ✅ 已实现，支持文档内引用和文件引用 |

### 3.3 控制属性

| 属性 | 适用范围 | 格式 | 说明 | 实现状态 |
|------|---------|------|------|---------|
| **schema** | 根标签 | URI | 提供验证规则来源，指向schema定义。 | ⏳ 保留属性，第一期暂不实现schema验证 |
| **mode** | 根标签 | 枚举值 | 控制解析器严格程度。可选值："strict"、"loose"(默认)。 | ⚪ 第一期基本实现，在关键验证点使用 |

## 4. 扩展机制

### 4.1 命名空间与扩展属性

DPML提供完整的扩展机制，允许通过命名空间和扩展属性创建自定义功能：

- **命名空间**：通过`x-namespace`属性定义自定义命名空间，允许引入特定领域的标签集
- **扩展属性**：所有以`x-`开头的属性被保留用于扩展，不受DPML核心规范约束

扩展属性工作原理：
1. 基础DPML解析器忽略所有`x-`前缀的属性，确保向后兼容性
2. 插件可以注册处理器来识别和处理特定的扩展属性
3. 多个插件可以协同工作，各自处理自己的命名空间

```xml
<!-- 扩展属性示例 -->
<tag x-plugin-feature="value" x-another-extension="123">
  内容
</tag>
```

### 4.2 插件化架构

DPML采用插件化架构，允许:

1. **核心层**：DPML基础规范和解析机制
2. **插件层**：扩展特定功能的模块，如特殊标签处理器、自定义协议等
3. **应用层**：基于DPML构建的完整框架，如提示词引擎、代理系统等

插件可以通过以下方式扩展DPML:
- 注册自定义标签处理器
- 添加新的@协议处理程序
- 提供特殊内容转换器
- 实现自定义验证规则

```javascript
// 插件注册示例（伪代码）
dpml.registerPlugin({
  namespace: 'finance',
  tagHandlers: {
    'market-analysis': handleMarketAnalysis
  },
  protocolHandlers: {
    'stockapi': handleStockApiProtocol
  }
});
```

## 5. 标签继承机制

### 5.1 标签继承规则

当使用`extends`属性继承其他标签定义时，DPML规定了以下继承规则：

- **单层继承**：标签只允许继承一次，不支持多层继承链
- **同类型限制**：标签只能继承相同类型的标签（如`<role>`只能继承`<role>`）
- **路径支持**：跨文件继承支持三种路径格式
  - 相对路径：`extends="./templates/base-role.dpml#assistant"`
  - 绝对路径：`extends="/templates/base-role.dpml#assistant"`
  - HTTP路径：`extends="https://example.com/templates/base-role.dpml#assistant"`
- **ID引用**：同文件内使用ID引用：`extends="base-assistant"`

### 5.2 属性继承规则

在标签继承过程中，属性按以下规则处理：

- **子优先原则**：当前标签的属性始终覆盖继承标签的同名属性
- **简单合并**：不支持特殊属性类型（如列表、对象）的复杂合并策略
- **全属性继承**：继承标签的所有未被覆盖的属性都会被继承

### 5.3 内容继承规则

内容继承遵循简单的二元原则：

- **当前标签有内容时**：完全替换继承标签的内容
- **当前标签无内容时**：完全继承基础标签的内容
- **内容边界**：空白内容和注释不视为有效内容

### 5.4 错误处理

继承机制的错误处理包括：

- **继承不存在**：当extends引用的目标不存在时，抛出清晰错误
- **类型不匹配**：当尝试继承不同类型标签时，提供类型错误警告
- **循环检测**：检测并报告简单的循环依赖（A→B→A）

```xml
<!-- file: base-templates.dpml -->
<role id="base-assistant" name="assistant">
  我是一个AI助手，可以回答各种问题。
</role>

<!-- file: custom.dpml -->
<!-- 继承并覆盖内容 -->
<role extends="./base-templates.dpml#base-assistant" x-tone="friendly">
  我是一个友好的AI助手，很高兴能帮助您解决问题！
</role>

<!-- 仅继承内容，不添加新内容 -->
<role extends="./base-templates.dpml#base-assistant" x-expertise="technical">
  <!-- 空内容，将继承base-assistant的内容 -->
</role>
```

## 6. @ 符号引用系统

DPML定义了统一的`@`符号系统作为在Markdown内容中引用各类资源的方法。这是DPML最核心和独特的特性之一。

### 6.1 基本语法

`@`符号后跟随资源标识符：

```
@identifier
```

### 6.2 引用类型

#### 内部引用

引用同一DPML文档内定义的资源：

```
@resource-id  // 引用id="resource-id"的资源
```

#### URI引用

直接引用各种URI协议的资源：

```
@http://example.com/document.pdf  // 网络HTTP资源
@https://secure-site.org/api-docs  // 安全HTTPS资源
@file:///local/path/to/document.docx  // 本地文件系统资源
```

#### 复合引用

引用资源的特定部分：

```
@resource-id#section  // 引用特定章节或部分
```

### 6.3 引用处理约定

DPML采用"约定大于配置"的思想处理@符号引用：

- **引擎处理**：针对内部引用的资源，由引擎负责获取和处理
- **模型处理**：针对直接URI引用，保留原始语法由模型自行理解处理
- **插件扩展**：通过插件系统可以扩展支持新的协议和处理方式

### 6.4 未来扩展方向

@符号引用系统设计为可扩展架构，可支持：

#### 扩展协议
```
@github://organization/repo/path/to/file  // GitHub资源
@gdrive://document-id  // Google Drive文档
@notion://page-id  // Notion页面
```

#### 查询参数
```
@database-id?query=SELECT * FROM users  // 数据库查询
@api-endpoint?param=value&limit=10  // API参数
```

#### 版本控制
```
@resource-id@v2.1  // 引用特定版本
```

#### 转换指令
```
@image.png:base64  // 转换为base64编码
@document.pdf:summary  // 获取摘要
```

## 7. 内容格式

DPML统一使用Markdown作为内容格式，推荐遵循CommonMark规范，但具体实现可以支持更多Markdown扩展。

### 7.1 Markdown基本格式

所有标签的内容使用Markdown格式：

```xml
<any-tag id="unique-id">
  # 主标题
  
  ## 小节标题1
  - 要点1
  - 要点2
  
  ## 小节标题2
  1. 有序列表项1
  2. 有序列表项2
</any-tag>
```

### 7.2 Markdown扩展

实现可以支持各种Markdown扩展，但DPML核心规范不对此做硬性规定。

## 8. 结语

DPML作为一种元规范，提供了统一的结构原则和扩展机制，它的核心价值在于：

- **统一结构** - 提供一致的XML+Markdown结构范式
- **引用系统** - 定义通用的@符号引用机制
- **插件化设计** - 支持通过插件扩展功能
- **模块化架构** - 促进组件的复用和组合

通过将DPML设计为元规范，我们可以构建一个生态系统，允许社区贡献各种插件和扩展，同时保持核心规范的简洁和稳定。DPML本身不包含特定领域的实现细节，而是为各种实现提供统一的基础框架。

## 9. 实现状态图例

本文档中使用以下图标标注属性的实现状态：

| 图标 | 状态说明 |
|------|---------|
| ✅ | 已完全实现 |
| ⚪ | 部分实现或基础实现 |
| ⏳ | 保留属性，暂未实现 | 