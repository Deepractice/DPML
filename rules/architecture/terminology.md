# DPML架构术语表

本文档定义了DPML类库架构中使用的核心术语。

## 架构层级 (Layers)

**API层**
: 类库对外暴露的函数接口集合。最薄的一层，不包含业务逻辑，只负责委托Core层功能。

**Types层**
: 定义所有API涉及的数据结构类型。只包含数据结构定义，不包含行为逻辑，纯数据结构。

**Core层**
: 包含所有内部实现代码的层级。按功能模块组织，实现所有业务逻辑。

**Test层**
: 包含所有测试代码的层级，按被测试组件组织结构。

## 模块层级（Modules）

**模块 (Module)**
: Core层内按功能划分的逻辑单元。

**模块服务 (Module Service)**
: 模块的主要服务实现，负责提供模块门面、实现特定模块的业务逻辑、组件协调和流程编排。融合了领域服务和应用服务的职责。

## 组件类别

**协调组件**
: 负责组织和控制其他组件的执行流程、调度和协作的组件。

**执行组件**
: 负责执行具体业务流程和算法的组件。包括数据处理、转换、验证和适配等核心功能实现。

**状态管理组件**
: 负责管理系统状态、组件注册和数据共享的组件。

**创建组件**
: 负责对象创建和配置的组件。

## 设计原则术语

**函数式API**
: 采用纯函数作为API主要形式，不依赖对象状态，通过入参显式传递依赖。

**不可变原则**
: 操作数据时不直接修改传入参数，而是返回新的数据结构。

**API委托原则**
: API层作为薄层，不包含业务逻辑，主要职责是委托Core层的模块服务功能。

**渐进式API暴露**
: 从简单高层API开始，随项目发展逐步暴露更多底层API的策略。

**类型安全设计**
: 充分利用TypeScript类型系统，确保代码类型安全，减少运行时错误。

**对外类型**
: 存放在`types/`目录下，作为API对外暴露的数据结构类型定义，体现系统对外接口。

**内部类型**
: 定义在`core/`目录下相关模块中的类型，仅供内部实现使用，不对外暴露。

**对外类型与内部类型区分**
: 对外暴露的类型(Types层)与内部实现类型(Core层)的明确区分，用于约束类型的可见范围和使用场景。

**单一职责原则**
: 每个组件或函数只负责一项明确的功能，具有高内聚性。

**纯函数设计**
: 固定输入产生固定输出，无副作用，不依赖外部状态。

**显式参数传递**
: 通过函数参数明确传递依赖，避免依赖隐式上下文或全局状态。

**关注点分离**
: 将不同职责的代码分离到不同模块，使系统各部分职责清晰。

**门面模式**
: 为子系统提供统一的简化接口，隐藏内部实现复杂性。

**组合优于继承**
: 优先使用组合而非继承来构建复杂类型和组件关系。

**约定大于配置**
: 通过预定义的约定减少需要的配置，提高开发效率和一致性。

**最小知识原则**
: 组件只应与直接相关的组件交互，减少组件间耦合。

**单向数据流**
: 数据按照明确的方向在系统中流动，便于追踪和理解。

**状态封装**
: 将可变状态封装在明确的组件内，而不是分散在整个系统中。

**依赖注入**
: 通过参数或构造函数接收依赖，而非在组件内部创建依赖。

**分层架构**
: 系统按照关注点分离原则在垂直方向上的划分，每一层具有特定的职责。

**薄层设计**
: 某些层(如API层)保持轻量，只包含简单逻辑，主要负责委托和转发。

**领域驱动设计**
: 根据业务领域组织代码，而非技术组件类型。

**就近定义原则**
: 内部类型应与使用它们的代码放在同一模块中，避免跨模块依赖。

**类型转换**
: 当内部类型需要转换为对外类型时，应明确定义转换函数，确保类型一致性。

**统一导出**
: 使用`index.ts`统一导出所有类型，为外部使用者提供一致的访问点。

## 组件关系术语

**委托关系**
: API层委托模块服务的关系，几乎是一对一映射。

**协调关系**
: 模块服务协调业务类和内部服务类的关系。

**依赖关系**
: 业务类通过构造函数注入依赖的关系模式。

**状态共享关系**
: 内部服务类在多个组件间共享状态的关系模式。

## 文件内容组织

**单一类文件**
: 文件仅包含一个类的定义及其相关实现代码。

**单一接口文件**
: 文件仅包含一个接口或类型的定义。

**函数集合文件**
: 文件包含多个相关函数的定义，不包含类或接口。

**类型集合文件**
: 文件包含多个相关类型定义，如接口、类型别名等。

**常量/枚举文件**
: 文件主要包含常量定义或枚举类型。

**混合内容文件**
: 文件包含多种不同类型的定义(函数、类、接口等)。

**空壳重导出文件**
: 文件不包含实际实现，仅重导出其他模块的内容。

## 代码元素组织

### 接口类型

**数据接口 (Data Interface)**
: 只包含数据字段而不包含方法的接口定义。

**契约接口 (Contract Interface)**
: 包含方法签名的接口定义，用于定义组件的行为契约。

**接口继承 (Interface Inheritance)**
: 一个接口继承自另一个接口的关系。

### 类类型

**抽象类 (Abstract Class)**
: 包含部分实现和抽象方法的类，不能直接实例化。

**实现类 (Implementation Class)**
: 实现特定接口或继承抽象类的具体类。

**工具类 (Utility Class)**
: 包含静态方法的类，不需要实例化。

**值对象类 (Value Object)**
: 表示不可变值的类，具有相等性比较和不可变特性。

**泛型类 (Generic Class)**
: 使用类型参数定义的类，能够处理多种类型。

### 函数类型

**纯函数 (Pure Function)**
: 不依赖外部状态且不产生副作用的函数，固定输入产生固定输出。

**高阶函数 (Higher-Order Function)**
: 接受函数作为参数或返回函数的函数。

**回调函数 (Callback Function)**
: 作为参数传递给其他函数并在特定条件下被调用的函数。

**函数工厂 (Function Factory)**
: 创建并返回特定功能函数的工厂函数。

### 命名空间组织

**命名空间对象 (Namespace Object)**
: 将相关功能组织在单一对象下的模式。

### 高级类型

**类型别名 (Type Alias)**
: 使用type关键字创建的类型定义。

**泛型约束 (Generic Constraint)**
: 限制泛型类型参数必须满足特定条件的类型声明。

**条件类型 (Conditional Type)**
: 基于条件表达式的类型，根据类型关系动态选择结果类型。

**映射类型 (Mapped Type)**
: 基于现有类型创建新类型的转换模式。

**索引签名类型 (Index Signature Type)**
: 允许对象包含任意数量同类型属性的类型声明。

**带有this参数的方法 (Method with this Parameter)**
: 在方法签名中显式声明this类型的方法定义。

**类型守卫**
: 使用类型谓词（如`is`）函数进行运行时类型检查，帮助TypeScript在特定分支中识别更具体的类型。

**类型断言**
: 使用`as`关键字或尖括号语法显式告诉编译器变量的特定类型的机制。

**类型收窄**
: 通过条件检查将宽泛类型（如联合类型）限制为更具体类型的技术。

**可辨识联合类型**
: 使用共同的标签字段创建的联合类型，便于类型区分和安全处理。

**泛型传递**
: 在架构分层中，泛型参数从顶层API一直传递到底层实现的设计模式。

## 命名风格术语

### 命名法

**大驼峰命名法 (PascalCase)**
: 每个单词首字母大写，不使用分隔符。用于类名、接口名、类型名和枚举名。

**小驼峰命名法 (camelCase)**
: 第一个单词首字母小写，后续单词首字母大写。用于变量名、函数名、方法名和属性名。

**全大写下划线分隔 (UPPER_SNAKE_CASE)**
: 所有字母大写，单词间用下划线分隔。用于常量名。

**小写下划线分隔 (snake_case)**
: 所有字母小写，单词间用下划线分隔。

**短横线命名法 (kebab-case)**
: 所有字母小写，单词间用短横线分隔。用于文件名、目录名和包名。

### 前后缀命名

**类型前缀**
: 类型参数名称使用单个大写字母或以`T`开头。

**接口前缀**
: 接口名的前缀标记，如`I`前缀表示接口。

**枚举后缀**
: 枚举名使用的后缀，如`Enum`后缀。

**函数型组件后缀**
: 明确组件职责的后缀，如`Service`、`Factory`等。

**内部成员前缀**
: 私有成员、保护成员的前缀，如下划线`_`。

### 语义命名

**布尔变量前缀**
: 布尔类型变量和函数的前缀，如`is`、`has`、`can`、`should`等。

**动词开头函数**
: 以动作动词开头的函数命名方式。

**获取/设置函数**
: 获取值和设置值的函数命名约定，如`get`和`set`前缀。

**集合名词复数**
: 使用名词复数形式表示集合、数组或列表的命名方式。

**单一对象单数**
: 使用名词单数形式表示单个对象的命名方式。

**回调函数命名**
: 回调函数参数的命名方式，如`Callback`或`Fn`后缀。

**多类型文件命名**
: 包含多个相关类型的文件使用复数形式或领域名称命名，如`Errors.ts`或`ValidationTypes.ts`。

### 特殊命名

**缩写命名**
: 常用缩写在命名中的使用方式。

**临时变量命名**
: 临时变量的命名约定。

**异步函数命名**
: 异步函数的命名约定，如`async`前缀或`Async`后缀。

**常量命名**
: 不同作用域常量的命名约定。

**文件与导出命名**
: 文件名与其导出内容的命名关系。

## 目录结构术语

**根目录**
: 包含API层、Types层和Core层的顶级目录。

**模块目录**
: Core层下按功能划分的一级子目录。

**API目录**
: 存放所有对外暴露API的目录。

**类型目录**
: 存放所有对外暴露数据类型的目录。

## 图表表示术语

### 架构图类型

**模块级完整UML**
: 跨层级业务模块类图，展示模块内所有关键组件及其在不同架构层级间的关系。

**模块级完整序列图**
: 跨层级业务流程序列图，展示请求如何从API层传递到底层实现并返回结果。

**架构概览图**
: 表示整体架构结构的高层次图表，主要展示不同层级和模块间的关系。

**数据流图**
: 展示系统中数据如何流动的图表。

### UML类图标记

**组件类型标记**
: 使用`<<>>`语法标记的组件类型。

**文件路径注释**
: 使用`note for`语法为组件添加的文件路径注释。

**关系表示**
: 使用不同类型的箭头表示组件间关系。

### 序列图标记

**参与者 (Participant)**
: 序列图中的实体，表示系统中的组件或角色。

**生命线 (Lifeline)**
: 表示参与者存在时间的垂直线。

**消息 (Message)**
: 参与者之间传递的信息，使用箭头表示。

**激活条 (Activation)**
: 表示参与者处于活动状态的时间段。

**分组 (Group)**
: 对相关消息进行分组，表示条件、可选和循环等控制流。

### 图表与代码映射关系

**类型标记映射**
: UML类图中的标记与代码元素的对应关系。

**关系表示映射**
: UML关系表示与代码中组件关系的对应关系。

**文件路径映射**
: UML中文件路径注释与实际目录结构的对应关系。

**序列图参与者映射**
: 序列图中参与者与代码组件的对应关系。 