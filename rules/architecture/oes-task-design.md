# OES任务设计规则

## 1. 概述

OES（目标-环境-成功标准）框架是一种任务设计方法，用于结构化地定义任务，使开发人员能够清晰地理解、执行和验证任务。本文档定义了DPML项目中使用OES框架设计任务的规则和最佳实践。

## 2. OES框架定义

OES框架将每个任务拆分为三个核心部分：

**目标 (Objective)**：
- 明确定义任务预期达成的结果
- 划定任务的边界和约束
- 阐明任务的意义和价值

**环境 (Environment)**：
- 提供任务执行所需的全部上下文信息
- 封装任务相关的代码、文档和资源
- 定义任务的技术和业务约束

**成功标准 (Success Criteria)**：
- 客观定义任务完成的验收条件
- 提供不同层次的完成标准
- 建立任务结果的评估框架

## 3. 为何使用OES框架

在DPML项目中采用OES框架的主要理由：

1. **降低任务沟通成本**：通过结构化定义任务，减少开发过程中的沟通误解和反复确认
2. **提高任务自主性**：使开发人员能够在充分理解上下文的情况下自主完成任务
3. **促进TDD实践**：将测试通过明确定义为成功标准，强化测试驱动开发
4. **支持并行开发**：清晰界定任务边界和依赖关系，便于并行开发
5. **简化进度追踪**：通过明确的成功标准，便于评估任务完成情况

## 4. 任务设计规则

### 4.1 目标(O)设计规则

1. **具体且可验证**：目标必须具体、明确，避免模糊表述
2. **边界清晰**：明确说明任务的范围和边界，指出不属于任务范围的内容
3. **价值导向**：说明任务实现后的价值和作用
4. **结果描述**：描述预期结果，而非实现过程
5. **适度细化**：颗粒度适中，既不过于宏观也不过于微观

### 4.2 环境(E)设计规则

环境应包含以下层次结构：

1. **代码相关**：
   - 需要修改的核心文件路径和描述
   - 相关接口和类型定义
   - 依赖的组件和服务

2. **测试相关**：
   - 相关测试文件路径和用例编号
   - 失败测试的错误信息
   - 测试期望的行为描述

3. **实现要点**：
   - 需要实现的方法和函数
   - 关键算法思路或逻辑流程
   - 参考代码片段或伪代码

4. **注意事项**：
   - 潜在的技术难点
   - 常见错误和规避方法
   - 性能、安全或兼容性要求

### 4.3 成功标准(S)设计规则

成功标准应分为三个层次，并以测试通过为核心标准：

1. **基础达标**：
   - 通过相关的测试用例是最基本的成功标准
   - 所有单元测试通过
   - 该功能相关的集成测试通过
   - 代表"可接受"的完成状态

2. **预期品质**：
   - 满足项目整体质量标准
   - 所有测试(包括端到端测试)全部通过
   - 符合代码规范和样式要求
   - 代表"良好"的完成状态

3. **卓越表现**（可选）：
   - 超出基本测试覆盖的优化
   - 可能包括性能优化、额外测试编写等
   - 代表"出色"的完成状态

由于DPML项目采用TDD开发模式，测试通过应当作为判断任务完成的主要客观标准。

## 5. OES任务模板

```markdown
# AI执行誓词

作为DPML项目的AI开发者，我庄严宣誓：

## 思考准则
我将以专业类库开发者的思维模式思考，遵循TDD原则，确保代码的可测试性、可维护性和架构一致性。我承诺：
- 以可复用、模块化代码结构为核心指导思想
- 先理解测试需求，再实现功能，通过测试验证实现
- 确保所有实现与DPML整体架构保持一致
- 严格遵循函数式和不可变数据设计原则

## 执行承诺
我将遵循严格的执行流程，不偏离既定规范。我承诺：

**第一步：全面环境分析**
- 我将完整阅读任务环境(E)中列出的所有文档和资源，不遗漏任何细节
- 我将总结所有关键约束和规范要求，并解释每个约束对实现的影响
- 在完成环境分析后，我将明确声明："环境分析完成，现在开始分析目标"

**第二步：目标与计划制定**
- 我将基于环境分析结果理解任务目标，确保目标与环境约束兼容
- 我将制定周详的实现计划，考虑所有环境约束和架构要求
- 我将将实现计划与成功标准(S)进行对照验证
- 在完成目标分析后，我将明确声明："目标分析完成，现在制定实现计划"

**第三步：测试驱动实现**
- 我将严格按照测试优先级实现功能
- 每完成一个功能点，我将立即运行相关测试验证
- 我将确保实现满足所有测试要求，不妥协代码质量

**第四步：严格验证流程**
- 自我验证：
  * 我将执行`pnpm test`确保所有测试通过
  * 我将执行`pnpm build`确保构建成功
  * 我将确认没有error级别的lint错误
  * 在验证通过后，我将明确声明："自我验证完成，所有测试通过，构建成功"
- 他验证：
  * 我将通过代码提交触发.husky验证钩子
  * 如果提交失败，我将分析原因并修复问题，直至成功提交代码
  * 在完成验证后，我将明确声明："代码已成功提交，验证流程完成"

我理解这些规范的重要性，并承诺在整个任务执行过程中严格遵守。我将在每个关键阶段做出明确声明，以证明我始终遵循规范执行。

---

## 任务标题

**目标(O)**:
- [明确具体的预期结果]
- [目标的边界和约束]
- [目标的价值和意义]

**环境(E)**:
- **代码相关**:
  - [相关文件路径和说明]
  - [核心接口和类型]
  - [依赖组件]
  
- **测试相关**:
  - [相关测试用例]
  - [失败测试信息]
  - [测试期望]

- **实现要点**:
  - [需实现的方法]
  - [关键算法思路]
  - [参考代码片段]

- **注意事项**:
  - [潜在难点]
  - [规避常见错误]
  - [特殊要求]

**成功标准(S)**:
- **基础达标**:
  - [相关单元测试通过]
  - [相关集成测试通过]
  
- **预期品质**:
  - [所有相关测试通过，包括端到端测试]
  - [代码符合项目规范]
  
- **卓越表现**:
  - [性能达到指定指标]
  - [额外优化或扩展]
```

## 6. 任务关系和组织

### 6.1 任务分解规则

1. **功能完整性**：每个任务应该实现完整的功能单元
2. **测试驱动**：任务边界应尽可能与测试边界对齐
3. **依赖最小化**：减少任务间的依赖，增强并行开发能力
4. **复杂度平衡**：任务复杂度应尽量均衡，避免出现过大或过小的任务

### 6.2 任务依赖表示

在任务设计中，应明确表示任务间的依赖关系：

1. **前置任务**：当前任务依赖的其他任务
2. **后续任务**：依赖当前任务的其他任务
3. **依赖类型**：
   - 强依赖：必须等待前置任务完成
   - 弱依赖：可并行开发但集成时依赖

### 6.3 任务文件组织规则

1. **命名规则**：任务文件必须遵循`[module]-[ordinal].task.md`格式命名
   - `module`: 模块名称，如parsing、document、validation等
   - `ordinal`: 序号，从01开始，表示执行顺序
   - 示例：`parsing-01.task.md`, `document-03.task.md`

2. **存放位置**：所有任务文件必须存放在对应包目录下的`tasks`子目录中
   - 路径格式：`packages/[package]/tasks/[module]-[ordinal].task.md`
   - 示例：`packages/core/tasks/parsing-01.task.md`

3. **测试覆盖要求**：
   - 一个模块的所有任务合在一起必须覆盖该模块的所有测试用例
   - 不允许有漏掉的测试用例
   - 在分配任务时需要确保测试用例覆盖的完整性

## 7. 基于TDD的OES任务设计

针对测试驱动开发(TDD)场景的OES任务设计特点：

1. **测试优先引用**：环境部分应首先引用相关测试用例，包括测试ID和测试文件路径
2. **测试即成功标准**：明确以测试通过作为最基本的成功标准，而非功能描述
3. **测试失败信息**：明确引用测试失败的错误信息，帮助开发人员理解需要解决的问题
4. **测试覆盖范围**：环境中应明确列出该任务需要解决的所有失败测试
5. **增量测试通过**：对于复杂任务，可指定测试通过的优先级顺序，允许增量开发

在DPML项目中，所有任务的成功标准均应直接关联到具体的测试用例。由于测试代码已经提前开发完成，开发人员可以直接参考测试了解功能需求和验收标准。

## 8. 最佳实践

### 8.1 任务描述最佳实践

1. **焦点明确**：每个任务专注于一个明确的功能或修复
2. **语言精确**：使用精确的技术术语，避免模糊表述
3. **代码引用**：使用代码片段说明关键实现
4. **图示辅助**：适当使用图表辅助解释复杂逻辑
5. **循序渐进**：按照合理顺序组织环境信息

### 8.2 目标设计最佳实践

1. **行动导向**：使用动词开头清晰表述行动
2. **数量适中**：通常包含2-4个具体目标点
3. **结果量化**：尽可能使目标可量化
4. **层次清晰**：主要目标和次要目标区分明确

### 8.3 环境设计最佳实践

1. **由外到内**：先概述整体环境，再深入具体细节
2. **关联突出**：强调各环境要素之间的关联
3. **实例结合**：使用具体实例说明抽象概念
4. **完备性**：环境信息应足够完整，不需要额外查找

### 8.4 成功标准设计最佳实践

1. **测试直接关联**：每项成功标准应直接关联到特定的测试用例或测试集
2. **层次递进**：不同层次标准应有明显递进关系，从基本测试通过到全面测试通过
3. **失败测试优先**：重点关注当前失败的测试，使其成为基础达标的关键标准
4. **测试覆盖全面**：确保成功标准覆盖所有相关测试类型（单元、集成、端到端）
5. **具体可执行**：提供具体的测试命令或步骤，使开发人员能方便地验证成功标准
6. **完全覆盖**：一个模块的所有任务组合起来必须覆盖该模块的所有测试用例，不能有遗漏

## 9. 示例

### 实例：实现XML解析器组件

```markdown
## 任务: 实现XML解析器

**目标(O)**:
- 实现一个符合`IXMLParser`接口的XML解析器类
- 解决"XML parser not implemented"错误
- 为DPML解析功能提供基础XML解析能力

**环境(E)**:
- **代码相关**:
  - `packages/core/src/core/parsing/types.ts` - 包含`IXMLParser`接口定义
  - `packages/core/src/core/parsing/parserFactory.ts` - 需要引入解析器的工厂
  
- **测试相关**:
  - `packages/core/src/__tests__/unit/core/parsing/XMLAdapter.test.ts` - 展示了对解析器的期望
  - 失败错误: "XML parser not implemented"
  - 测试期望解析器能处理基本XML结构及属性

- **实现要点**:
  - 创建新文件 `packages/core/src/core/parsing/xmlParser.ts`
  - 实现三个关键方法:
    ```typescript
    parse(content: string): XMLNode;
    parseAsync(content: string): Promise<XMLNode>;
    configure(options: Record<string, unknown>): void;
    ```
  - XMLNode结构要求: type, name, attributes, children, text
  
- **注意事项**:
  - 可考虑使用现有XML库或简单实现
  - 解析器应有合理的错误处理机制
  - 异步解析实现应高效处理大文件

**成功标准(S)**:
- **基础达标**:
  - `XMLAdapter.test.ts`的所有单元测试通过，特别是`UT-XMLAdapter-01`到`UT-XMLAdapter-04`
  - 解决集成测试中的"XML parser not implemented"错误
  
- **预期品质**:
  - 所有相关集成测试通过：`IT-Parsing-01`到`IT-Parsing-04`
  - 端到端测试中的XML解析错误消失
  - 解析错误提供有用的错误信息和位置
  
- **卓越表现**:
  - 实现高效解析算法，处理大文件时性能良好
  - 支持更多XML特性(命名空间、CDATA等)
  - 为XML解析器编写完善的单元测试
```

## 10. AI执行誓词

针对AI开发者执行OES任务，必须遵循专门设计的执行誓词，确保其对任务环境和成功标准的充分理解。

### 10.1 誓词的目的与意义

AI执行誓词旨在解决AI在任务执行中常见的注意力分配问题，特别是过度关注目标(O)而忽略环境(E)和成功标准(S)的倾向。通过庄严的誓词形式，强化AI对环境分析和测试验证的重视。

誓词具有以下核心意义：
1. 建立思维框架：指导AI以专业类库开发者的思维模式思考
2. 规范执行流程：确保AI按照规定的步骤顺序执行任务
3. 要求明确声明：在关键节点要求明确声明，确认完成相应阶段
4. 强调验证重要性：突出自我验证和他验证的必要性

### 10.2 誓词内容结构

AI执行誓词包含以下核心部分：

1. **思考准则**：定义AI应采用的思维模式和设计原则
2. **执行承诺**：规定详细的执行步骤和要求
   - 第一步：全面环境分析
   - 第二步：目标与计划制定
   - 第三步：测试驱动实现
   - 第四步：严格验证流程

### 10.3 誓词应用规则

每个OES任务文档必须以"AI执行誓词"开头，确保AI执行者庄严承诺遵循规范。该誓词以正式宣誓形式表达，突显任务执行的严肃性与重要性。

AI执行者必须完整理解并接受誓词中的所有内容，将其视为不可违背的执行准则。AI必须在每个关键节点做出明确声明，确认已完成规定步骤，并准备进入下一阶段。只有在理解并接受誓词后，AI才能开始分析和执行任务。

若AI未按誓词要求执行任务，特别是跳过环境全面分析直接关注目标实现，应立即提醒其回到规范流程，重新从环境分析开始。任务设计者有责任确保AI严格遵循誓词，以保证开发质量和一致性。

### 10.4 誓词示例

以下是标准AI执行誓词的完整示例：

```markdown
# AI执行誓词

作为DPML项目的AI开发者，我庄严宣誓：

## 思考准则
我将以专业类库开发者的思维模式思考，遵循TDD原则，确保代码的可测试性、可维护性和架构一致性。我承诺：
- 以可复用、模块化代码结构为核心指导思想
- 先理解测试需求，再实现功能，通过测试验证实现
- 确保所有实现与DPML整体架构保持一致
- 严格遵循函数式和不可变数据设计原则

## 执行承诺
我将遵循严格的执行流程，不偏离既定规范。我承诺：

**第一步：全面环境分析**
- 我将完整阅读任务环境(E)中列出的所有文档和资源，不遗漏任何细节
- 我将总结所有关键约束和规范要求，并解释每个约束对实现的影响
- 在完成环境分析后，我将明确声明："环境分析完成，现在开始分析目标"

**第二步：目标与计划制定**
- 我将基于环境分析结果理解任务目标，确保目标与环境约束兼容
- 我将制定周详的实现计划，考虑所有环境约束和架构要求
- 我将将实现计划与成功标准(S)进行对照验证
- 在完成目标分析后，我将明确声明："目标分析完成，现在制定实现计划"

**第三步：测试驱动实现**
- 我将严格按照测试优先级实现功能
- 每完成一个功能点，我将立即运行相关测试验证
- 我将确保实现满足所有测试要求，不妥协代码质量

**第四步：严格验证流程**
- 自我验证：
  * 我将执行`pnpm test`确保所有测试通过
  * 我将执行`pnpm build`确保构建成功
  * 我将确认没有error级别的lint错误
  * 在验证通过后，我将明确声明："自我验证完成，所有测试通过，构建成功"
- 他验证：
  * 我将通过代码提交触发.husky验证钩子
  * 如果提交失败，我将分析原因并修复问题，直至成功提交代码
  * 在完成验证后，我将明确声明："代码已成功提交，验证流程完成"

我理解这些规范的重要性，并承诺在整个任务执行过程中严格遵守。我将在每个关键阶段做出明确声明，以证明我始终遵循规范执行。
```

此誓词必须放在每个OES任务文档的开头，确保AI执行者在开始任务之前充分理解并承诺遵守执行规范。

## 11. 与其他规则的关系

1. **测试用例设计规则**：OES任务设计与测试用例设计紧密关联，成功标准通常引用测试用例
2. **测试策略规则**：OES任务设计应遵循项目的整体测试策略
3. **架构概览规则**：任务设计应符合项目的架构原则
4. **UML表示规则**：可使用UML图表辅助说明任务的目标和环境

## 12. 总结

OES任务设计框架通过结构化定义任务的目标、环境和成功标准，为开发人员提供了清晰的任务蓝图。在DPML项目中，特别是基于TDD的开发场景下，OES框架能够有效降低任务沟通成本，提高开发效率，并确保代码质量。

通过遵循本文档定义的规则和最佳实践，项目团队可以创建高质量的任务设计，促进高效协作和优质交付。 