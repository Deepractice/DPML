# 架构概览规则

本文档定义了DPML类库架构总览和组件关系的强制规则。

## 1. 架构分层规则

DPML架构分为两个主要部分：

1. **顶层架构规则**:
   - **API层**: 最薄的一层，纯函数式接口，直接暴露给外部使用者
   - **Types层**: 纯数据结构定义，无行为逻辑

2. **Core内部实现规则**:
   - **模块服务层**: 提供业务功能，实现业务逻辑，协调领域组件
   - **领域层**: 包含业务类、内部服务类与工厂模块

架构分层图示：

```
                        ┌───────────────────────┐
                        │     外部使用者         │
                        └───────────┬───────────┘
                                    │
           ┌────────────────────────▼─────────────────────────┐
           │                  顶层架构                          │
           │  ┌─────────────────────────────────────────────┐ │
           │  │                  API 层                     │ │
           │  │    (函数式API接口，对外暴露，最薄的一层)        │ │
           │  └─────────────────────────────────────────────┘ │
           │                      │                           │
           │  ┌─────────────────────────────────────────────┐ │
           │  │                 types 层                    │ │
           │  │    (数据结构定义，无行为逻辑的纯类型)           │ │
           │  └─────────────────────────────────────────────┘ │
           └────────────────────────┬─────────────────────────┘
                                    │
           ┌────────────────────────▼─────────────────────────┐
           │                 core 内部实现                     │
           │                                                  │
           │  ┌──────────────────────────────────────────────┐ │
           │  │               模块服务层                     │ │
           │  │  ┌─────────────┐  ┌─────────────┐  ┌───────┐ │ │
           │  │  │parsingService│  │documentService│  │...   │ │ │
           │  │  └─────────────┘  └─────────────┘  └───────┘ │ │
           │  └──────────┬──────────────┬─────────────┬──────┘ │
           │             │              │             │        │
           │  ┌──────────▼──────┐ ┌─────▼───────┐ ┌───▼────────┐ │
           │  │ 解析领域         │ │ 文档领域    │ │ 注册表领域  │ │
           │  │                 │ │            │ │            │ │
           │  │ ┌─────────────┐ │ │ ┌────────┐ │ │ ┌────────┐ │ │
           │  │ │Parser       │ │ │ │Selector│ │ │ │TagReg. │ │ │
           │  │ │(业务类)      │ │ │ │(业务类)│ │ │ │(内部服务)│ │ │
           │  │ └─────────────┘ │ │ └────────┘ │ │ └────────┘ │ │
           │  │                 │ │            │ │            │ │
           │  │ ┌─────────────┐ │ │ ┌────────┐ │ │ ┌────────┐ │ │
           │  │ │工厂模块      │ │ │ │工厂模块│ │ │ │工厂模块 │ │ │
           │  │ └─────────────┘ │ │ └────────┘ │ │ └────────┘ │ │
           │  └─────────────────┘ └────────────┘ └────────────┘ │
           └──────────────────────────────────────────────────────┘
```

## 2. 数据流规则

1. **数据流方向规则**: 数据应按照标准的单向流动路径在系统中传递:
   - 请求数据从外部使用者经API层、模块服务层流向业务类/内部服务类
   - 响应数据沿相反方向返回给外部使用者

2. **数据流动过程规则**:
   - **请求入口规则**: 外部使用者必须通过API层函数进入
   - **API传递规则**: API层必须将请求传递给模块服务层
   - **业务逻辑规则**: 模块服务层必须实现业务逻辑、组织功能并协调业务类/内部服务类
   - **组件创建规则**: 模块服务层必须使用工厂创建所需的业务类/内部服务类实例
   - **业务处理规则**: 业务类/内部服务类必须处理请求，操作数据结构
   - **数据返回规则**: 处理后的数据结构必须通过各层返回给外部使用者

数据流示意图：

```
            请求数据流向                         响应数据流向
            ────────────>                       <────────────
┌────────┐    ┌────────┐    ┌────────────┐    ┌────────┐
│        │    │        │    │            │    │        │
│ 外部   │    │  API   │    │ 模块       │    │业务类/ │
│使用者  │───>│ (函数) │───>│ 服务层     │───>│内部服务 │
│        │    │        │    │            │    │        │
└────────┘    └────────┘    └────────────┘    └────────┘
                │                │                │
                │                │                │
                └────────────────┘                ▼
                         │                   ┌────────┐
                         │                   │        │
                         │                   │数据类型│
                         │                   │        │
                         │                   └────────┘
                         │                       ▲
                         │       ┌────────┐      │
                         └──────>│ 工厂   │──────┘
                                 │ 模块   │
                                 └────────┘
```

## 3. 组件关系规则

### 3.1 组件关系矩阵

下表定义了DPML架构中各核心组件之间的访问和依赖关系规则：

| 组件类型 | 可以访问 | 不可访问 | 被谁访问 | 依赖关系 |
|---------|---------|----------|---------|---------|
| **API函数** | 模块服务层 | 业务类、内部服务类、工厂 | 外部使用者 | 依赖模块服务层 |
| **Types类型** | - | - | 所有组件 | 纯数据结构，无依赖 |
| **模块服务层** | 业务类、内部服务类、工厂、其他模块服务 | API函数 | API函数 | 依赖业务类、内部服务类和工厂模块 |
| **业务类** | 其他业务类、内部服务类、Types类型 | API函数、模块服务层 | 模块服务层 | 通过构造函数注入依赖 |
| **内部服务类** | Types类型 | API函数、模块服务层 | 模块服务层、业务类 | 通常作为单例，状态独立 |
| **工厂模块** | 业务类、内部服务类、其他工厂 | API函数、模块服务层 | 模块服务层 | 负责创建和管理组件实例 |

### 3.2 组件交互规则

1. **单向依赖规则**: 组件依赖方向为API → 模块服务 → 业务类/内部服务类，避免循环依赖
2. **层级访问控制规则**: 上层组件只能访问直接下层组件，不能跨层访问
3. **顶层与core层分离规则**: 顶层架构(API函数、Types类型)与core内部实现严格分离
4. **职责边界规则**: 每种组件具有明确职责边界，不越权操作
5. **可见性控制规则**: 内部组件对外部不可见，保持封装性

### 3.3 层次职责区分

| 层次 | 主要职责 | 位置 | 命名规范 | DDD对应 |
|------|---------|------|---------|---------|
| **API层** | 对外暴露接口，委托模块服务 | `/api` | 小写领域名<br>如`parser.ts` | 接口层 |
| **模块服务层** | 业务逻辑实现，组件协调，功能聚合 | `/core/[domain]` | 小驼峰+Service<br>如`parsingService.ts` | 应用服务层+领域服务层 |

### 3.4 典型交互模式

API层直接访问模块服务层:

```typescript
// API层 - api/parser.ts
export * from '../core/parsing/parsingService';

// 模块服务层 - core/parsing/parsingService.ts
import { Parser } from './Parser';
import { Validator } from '../validation/validator';

export function parse(content: string): Document {
  const validator = new Validator();
  const parser = new Parser({ validator });
  return parser.parse(content);
}

// 跨领域调用示例
import { validateDocument } from '../validation/validationService';

export function parseAndValidate(content: string): ValidationResult {
  const doc = parse(content);
  return validateDocument(doc);
}
```

### 3.5 常见误区

1. **直接访问误区**: API层不得直接访问业务类或内部服务类
   ```typescript
   // 错误示例
   // api/document.ts
   import { Parser } from '../core/parsing/Parser';
   
   export function parse(content) {
     const parser = new Parser();
     return parser.parse(content);
   }
   ```

2. **位置错误误区**: 模块服务必须位于对应的领域目录内
   ```typescript
   // 错误示例
   // core/parsingService.ts - 应该在core/parsing/parsingService.ts
   export function parse(content) {
     // 实现...
   }
   ```

3. **责任混淆误区**: 模块服务不应忽略业务逻辑而只做简单委托
   ```typescript
   // 错误示例
   // core/parsing/parsingService.ts
   export * from './Parser'; // 不应直接导出业务类
   ```

4. **分层错误误区**: 不应在模块服务层之上再创建额外的抽象层
   ```typescript
   // 错误示例
   // core/parsing/parsingManager.ts - 不需要额外的Manager层
   import { parsingService } from './parsingService';
   
   export function parse(content) {
     return parsingService.parse(content);
   }
   ```

## 4. 错误处理架构规则

### 4.1 错误分类体系

1. **错误继承规则**: 项目必须建立清晰的错误类型继承层次
2. **领域错误规则**: 使用特定领域错误类型，而非通用Error

```typescript
// 基础错误类
export abstract class DPMLError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly severity: ErrorSeverity = 'error'
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

// 解析错误
export class ParseError extends DPMLError {
  constructor(
    message: string,
    public readonly location: SourceLocation
  ) {
    super(message, 'PARSE_ERROR');
  }
}
```

### 4.2 错误处理责任分配

1. **逐层错误处理规则**: 架构的每一层都有不同的错误处理职责

| 层次 | 错误处理职责 |
|------|------------|
| API层 | 直接传递模块服务层错误，不做额外处理 |
| 模块服务层 | 捕获业务类错误，转换为统一错误类型，添加上下文 |
| 业务类 | 抛出具体操作错误，附带详细上下文 | 