# 测试用例设计规则

本文档定义了DPML类库测试用例设计的强制规则。

## 1. 测试目录结构规则

### 1.1 测试目录组织

1. **测试根目录规则**: 所有测试文件必须放在包根目录下的`__tests__`目录中，与`src`目录平级
2. **测试类型划分规则**: 测试目录按测试类型进行组织，而非按架构层次
3. **标准测试类型目录**: 必须包含以下标准目录

```
packages/                # 包集合目录
  core/                  # 核心包 (包根目录)
    src/                 # 源代码根目录
      api/               # API层源码
      core/              # Core层源码
        parsing/         # 解析模块源码
        document/        # 文档模块源码
      types/             # Types层源码
    __tests__/           # 测试根目录
      unit/              # 单元测试
        api/             # API层单元测试
        core/            # Core层单元测试
          parsing/       # 解析模块单元测试
          document/      # 文档模块单元测试
      integration/       # 集成测试
        parsing-document/# 解析与文档模块集成测试
        document-rendering/ # 文档与渲染模块集成测试
      contract/          # 契约测试
        api/             # API层契约测试
        types/           # Types层契约测试
      e2e/               # 端到端测试
        parsing-workflow/# 完整解析工作流测试
        rendering-workflow/ # 完整渲染工作流测试
      fixtures/          # 测试夹具
        documents/       # 文档相关测试夹具
        parsers/         # 解析器相关测试夹具
      perform/           # 性能测试
        parsing/         # 解析性能测试
        rendering/       # 渲染性能测试
```

4. **模块目录组织**: 在各类型测试目录下，按照功能模块进行组织，保持与源代码结构的对应关系

### 1.2 测试文件命名规则

测试文件名应遵循以下命名规则：

1. **单元测试**：`[测试对象].test.ts`
2. **集成测试**：`[测试对象].integration.test.ts`
3. **契约测试**：`[测试对象].contract.test.ts`
4. **端到端测试**：`[测试对象].e2e.test.ts`
5. **性能测试**：`[测试对象].perf.test.ts` 
6. **夹具文件**：`[夹具名称].fixture.ts`

### 1.3 测试套件和用例命名

遵循以下命名规范，确保测试目的明确：

```typescript
// 单元测试
describe('UT-[Module]-[Feature]', () => {
  // 单个测试用例
  test('should [expected result] when [condition]', () => {
    // ...
  });
});

// 集成测试
describe('IT-[ModuleA]-[ModuleB]', () => {
  // ...
});

// 契约测试
describe('CT-[Provider]-[Consumer]', () => {
  // ...
});

// 端到端测试
describe('E2E-[Workflow]', () => {
  // ...
});

// 性能测试
describe('PERF-[Feature]', () => {
  // ...
});
```

### 1.4 测试文件结构

每个测试文件应遵循以下结构：

```typescript
/**
 * 模块的单元测试
 */
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { 
  createMockFunction, 
  fileSystemMock 
} from '@dpml/common/testing';
import { ModuleToTest } from '../../src/module-to-test';

describe('UT-Module-Feature', () => {
  // 设置测试夹具
  let fixture;
  
  // 每个测试前的设置
  beforeEach(() => {
    fixture = {
      // 初始化测试数据和模拟
    };
  });
  
  // 每个测试后的清理
  afterEach(() => {
    // 清理资源
  });
  
  // 按功能分组的测试用例
  describe('Feature A', () => {
    test('scenario 1', () => {
      // 安排 (Arrange)
      
      // 执行 (Act)
      
      // 断言 (Assert)
    });
    
    test('scenario 2', () => {
      // ...
    });
  });
  
  describe('Feature B', () => {
    // ...
  });
});
```

## 2. 测试用例文档组织规则

1. **层次化组织规则**: 测试用例文档必须采用三层结构组织：
   - 第一层：按测试类型分类（单元测试、集成测试、端到端测试等）
   - 第二层：按测试文件划分，明确指定文件路径和名称
   - 第三层：具体测试用例详情

2. **文件标识规则**: 每个测试文件部分必须包含完整的文件路径，使测试组织与代码结构保持一致。

3. **ID编码规则**: 每个测试用例必须有唯一的ID，采用以下格式：
   - 单元测试：`UT-[组件缩写]-[序号]`
   - 集成测试：`IT-[模块缩写]-[序号]`
   - 端到端测试：`E2E-[功能缩写]-[序号]`
   - 边界测试：`EC-[类型缩写]-[序号]`
   - 性能测试：`PF-[类型缩写]-[序号]`
   - 契约测试：`CT-[契约缩写]-[序号]`

4. **文档完整性规则**: 测试用例文档必须包含覆盖率指标、先决条件和测试依赖说明。

## 3. 测试用例表格设计规则

1. **标准列规则**: 测试用例表格必须包含以下标准列：
   - ID：唯一标识符
   - 测试用例名称：简明描述测试内容
   - 测试目的：阐明测试意图
   - 测试输入：明确输入数据
   - 期望结果：明确预期输出
   - Mock情况：描述需模拟的组件/数据

2. **用例名称规则**: 测试用例名称必须采用"[组件/功能]应[预期行为]"格式，如"parse方法应正确处理基本XML"。

3. **测试目的规则**: 每个测试目的描述必须以"验证..."开头，清晰表达测试意图。

4. **测试输入规则**: 测试输入必须具体明确，对于复杂输入应提供简化示例或引用测试夹具。

5. **期望结果规则**: 期望结果必须可验证，避免模糊表述，使用确切的输出描述或状态变化。

6. **Mock描述规则**: Mock情况必须详细描述被模拟的组件、返回值和交互方式，或明确标注"无需模拟"。

## 4. 测试覆盖范围规则

1. **功能覆盖规则**: 每个公共API和关键内部函数必须有至少一个正面测试用例和一个反面测试用例。

2. **路径覆盖规则**: 测试用例必须覆盖函数的所有主要执行路径，包括：
   - 正常路径：验证预期功能
   - 错误路径：验证错误处理
   - 边界路径：验证边界条件处理

3. **配置覆盖规则**: 对于可配置组件，必须测试默认配置和至少一种自定义配置。

4. **数据变体规则**: 必须为每个关键函数设计多样化的输入数据，包括：
   - 最小/空输入
   - 典型输入
   - 极限/边界输入
   - 错误/无效输入

5. **组合情景规则**: 集成和端到端测试必须包含对组件交互的组合测试，覆盖关键业务场景。

## 5. 契约测试规则

1. **契约测试范围规则**: DPML项目的契约测试**仅针对API层和Types层**进行，确保对外暴露接口的稳定性和一致性。

2. **API层契约测试规则**: 对于API层函数接口，契约测试必须验证：
   - 函数签名和参数类型的稳定性
   - 返回值类型和结构的一致性
   - 异常/错误处理的符合性
   - 接口行为的向后兼容性

3. **Types层契约测试规则**: 对于Types层类型定义，契约测试必须验证：
   - 类型结构定义的稳定性
   - 类型属性和关系的一致性
   - 类型兼容性和扩展性
   - 类型文档的准确性

4. **契约变更验证规则**: 对于任何契约更改，必须验证：
   - 向后兼容性（除非明确声明为破坏性变更）
   - 变更影响范围的评估
   - 变更文档化并通知使用者

5. **契约测试ID规则**: 契约测试用例ID必须采用以下格式：
   - API测试: `CT-API-[API名称]-[序号]`，如 `CT-API-Parser-01`
   - 类型测试: `CT-Type-[类型名称]-[序号]`，如 `CT-Type-DPMLNode-01`

## 6. 正反面测试平衡规则

1. **正面测试规则**: 正面测试必须验证组件在预期条件下的正确行为，包括：
   - 基本功能验证
   - 多种有效输入处理
   - 配置选项影响
   - 结果正确性验证

2. **反面测试规则**: 反面测试必须验证组件对异常情况的处理能力，包括：
   - 无效输入处理
   - 极端值处理
   - 错误情况恢复
   - 资源限制处理

3. **比例平衡规则**: 正面测试与反面测试的比例应大致维持在2:1，确保功能验证的同时有足够的异常处理覆盖。

4. **边界优先规则**: 在有限的测试资源下，应优先测试功能边界点和已知风险区域。

## 7. 模拟(Mock)策略规则

1. **最小模拟规则**: 应遵循最小模拟原则，只模拟当前测试单元直接依赖的外部组件。

2. **模拟精确性规则**: 模拟实现必须准确反映被模拟组件的行为约定，包括返回类型、错误抛出模式和副作用。

3. **模拟声明规则**: 每个测试用例必须在表格的"Mock情况"列明确声明：
   - 被模拟的组件/接口
   - 模拟的行为/返回值
   - 是否验证模拟组件的调用方式

4. **无模拟标记规则**: 不需要模拟的测试用例必须明确标记为"无需模拟"，而非留空。

5. **集成测试模拟规则**: 集成测试应尽量减少模拟，只模拟最外层依赖，如数据库或外部服务。

6. **端到端测试模拟规则**: 端到端测试应最小化模拟，优先使用实际组件，只模拟不可控的外部系统。

## 8. 测试夹具设计规则

1. **夹具独立规则**: 每个测试文件应有独立的测试夹具或明确引用共享夹具。

2. **夹具命名规则**: 测试夹具变量应使用描述性名称，如`validDocument`、`invalidInput`。

3. **夹具准备规则**: 测试夹具应在`beforeEach`钩子中准备，确保测试隔离。

4. **夹具复杂度规则**: 复杂测试夹具应使用工厂函数创建，支持自定义参数。

```typescript
// 测试夹具工厂示例
function createDocumentFixture(options?: {
  withAttributes?: boolean,
  nestedDepth?: number
}): DPMLDocument {
  // 创建文档夹具
}
```

## 9. 测试用例设计最佳实践

1. **简洁明确规则**: 每个测试用例应关注单一行为点，避免测试多个不相关功能。

2. **自描述规则**: 测试用例的名称和结构应足够清晰，无需额外注释即可理解测试意图。

3. **可重复规则**: 测试必须设计为可重复执行，不依赖执行顺序或外部状态。

4. **时间敏感规则**: 包含时间敏感逻辑的测试必须使用模拟时钟或可控时间源。

5. **数据变异规则**: 处理复杂输入的测试应设计多个变体，探索不同的数据特征。

## 10. 测试用例文档示例

以下是符合规则的测试用例文档示例：

### 10.1 单元测试示例

#### `packages/core/src/__tests__/unit/parsing/XMLAdapter.test.ts`

| ID | 测试用例名称 | 测试目的 | 测试输入 | 期望结果 | Mock情况 |
|----|------------|---------|---------|---------|---------|
| UT-XML-01 | parse方法应正确处理基本XML | 验证基本解析功能 | `"<tag>content</tag>"` | 返回正确的XML节点对象 | 模拟IXMLParser.parse返回预定义节点 |
| UT-XML-02 | parse方法应处理空XML | 验证空输入处理 | `""` | 返回表示空文档的节点 | 模拟IXMLParser.parse返回空节点 |
| UT-XML-03 | parse方法应传递错误 | 验证错误处理 | 无效XML字符串 | 抛出原始解析错误 | 模拟IXMLParser.parse抛出错误 |

### 10.2 契约测试示例

#### `packages/core/src/__tests__/contract/api/parserApi.contract.test.ts`

| ID | 测试用例名称 | 测试目的 | 测试输入 | 期望结果 | Mock情况 |
|----|------------|---------|---------|---------|---------|
| CT-PARSER-01 | parse API应维持类型签名 | 验证API契约稳定性 | 类型检查 | 符合公开文档的函数签名 | 无需模拟 |
| CT-PARSER-02 | parse API应返回符合DPMLDocument类型的结果 | 验证返回类型契约 | 有效DPML内容 | 返回的对象符合DPMLDocument接口 | 模拟parsingService，返回符合契约的数据 |
| CT-PARSER-03 | parse API应在错误时抛出指定类型异常 | 验证错误处理契约 | 无效内容 | 抛出ParseError类型错误 | 模拟parsingService抛出错误 |

### 10.3 集成测试示例

#### `packages/core/src/__tests__/integration/parsing/parsingFlow.integration.test.ts`

| ID | 测试用例名称 | 测试目的 | 测试输入 | 期望结果 | Mock情况 |
|----|------------|---------|---------|---------|---------|
| IT-FLOW-01 | 解析服务应协调适配器解析内容 | 验证解析流程协作 | `"<root><child/></root>"` | 返回完整DOM结构 | 模拟底层XML解析器，其他组件使用实际实现 |

## 11. 测试用例评审规则

1. **完整性评审规则**: 评审必须验证测试用例覆盖所有功能点和潜在问题区域。

2. **正确性评审规则**: 评审必须验证测试用例的预期结果与需求一致。

3. **可行性评审规则**: 评审必须确认测试用例可以实际编写和执行。

4. **平衡性评审规则**: 评审必须确认正面、反面和边界测试用例分布合理。 